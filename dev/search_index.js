var documenterSearchIndex = {"docs":
[{"location":"references/#Suggested-readings","page":"References and suggested readings","title":"Suggested readings","text":"","category":"section"},{"location":"references/#Theory-and-background","page":"References and suggested readings","title":"Theory and background","text":"","category":"section"},{"location":"references/","page":"References and suggested readings","title":"References and suggested readings","text":"The theory of time-bin continuous fockstates is introduced in [1] where it is used to derive the equations of motion for Waveguide QED systems. The numerical method in this library is heavily based on this approach, where instead of deriving the equations, the systems are solved by applying the operators themselves. The time-bin method is also used in [7] and [8].","category":"page"},{"location":"references/#Similar-approaches","page":"References and suggested readings","title":"Similar approaches","text":"","category":"section"},{"location":"references/","page":"References and suggested readings","title":"References and suggested readings","text":"The following is a list of approaches that are trying to solve problems that can also be treated with this library.","category":"page"},{"location":"references/","page":"References and suggested readings","title":"References and suggested readings","text":"[5] considers feedback in waveguide systems and uses a space-discretized waveguide picture with Monte Carlo trajectories\n[9] relates many approaches to solving WaveguideQED problems with each other and also introduces a framework that aims to deal with similar problems through master equations, photon counting and tracing out the waveguide.\nThe SLH formalism introduced in [10] and [10] uses cascaded cavities to simulate quantum pulses. Further work also includes: [11] [12]","category":"page"},{"location":"references/#Papers-where-we-reproduce-results-from","page":"References and suggested readings","title":"Papers where we reproduce results from","text":"","category":"section"},{"location":"references/","page":"References and suggested readings","title":"References and suggested readings","text":"The theoretical results in [3] are reproduced in Scattering on a two-level system.\nThe semi-infinite waveguide with feedback considered in is considered in [5] and we reproduce the results in Waveguide and Mirror\nThe fano transport studied in [13] and input-output relations formulated in [4] are described and studied in Input-Output Relations","category":"page"},{"location":"references/#References","page":"References and suggested readings","title":"References","text":"","category":"section"},{"location":"references/","page":"References and suggested readings","title":"References and suggested readings","text":"M. Heuck, K. Jacobs and D. R. Englund. Photon-photon interactions in dynamically coupled cavities. Physical Review A 101 (2020).\n\n\n\nB. Q. Baragiola, R. L. Cook, A. M. Branczyk and J. Combes. N-Photon wave packets interacting with an arbitrary quantum system. Physical Review A 86, 013811 (2012).\n\n\n\nH. L. Jeannic, A. Tiranov, J. Carolan, T. Ramos, Y. Wang, M. H. Appel, S. Scholz, A. D. Wieck, A. Ludwig, N. Rotenberg, L. Midolo, J. J. García-Ripoll, A. S. Sørensen and P. Lodahl. Dynamical photon-photon interaction mediated by a quantum emitter. Nature Physics 18, 1191–1195 (2022).\n\n\n\nS. Xu and S. Fan. Fano interference in two-photon transport. Physical Review A 94 (2016).\n\n\n\nS. A. Regidor, G. Crowder, H. Carmichael and S. Hughes. Modeling quantum light-matter interactions in waveguide QED with retardation, nonlinear interactions, and a time-delayed feedback: Matrix product states versus a space-discretized waveguide model. Physical Review Research 3, 023030 (2021).\n\n\n\nS. J. Whalen. Collision model for non-Markovian quantum trajectories. Physical Review A 100, 052113 (2019).\n\n\n\nM. Heuck, K. Jacobs and D. R. Englund. Controlled-Phase Gate Using Dynamically Coupled Cavities and Optical Nonlinearities. Physical Review Letters 124 (2020).\n\n\n\nS. Krastanov, K. Jacobs, G. Gilbert, D. R. Englund and M. Heuck. Controlled-phase gate by dynamic coupling of photons to a two-level emitter, npj Quantum Information 8, 103 (2022).\n\n\n\nK. A. Fischer, R. Trivedi and D. Lukin. Particle emission from open quantum systems. Physical Review A 98 (2018).\n\n\n\nA. H. Kiilerich and K. Mølmer. Input-Output Theory with Quantum Pulses. Physical Review Letters 123, 123604 (2019).\n\n\n\nF. Yang, M. M. Lund, T. Pohl, P. Lodahl and K. Mølmer. Deterministic Photon Sorting in Waveguide QED Systems. Physical Review Letters 128 (2022).\n\n\n\nV. R. Christiansen, A. H. Kiilerich and K. Mølmer. Interactions of quantum systems with pulses of quantized radiation: From a cascaded master equation to a traveling mode perspective. Physical Review A 107, 013706 (2023).\n\n\n\nK. B. Joanesarson, J. Iles-Smith, M. Heuck and J. Mørk. Few-photon transport in Fano-resonance waveguide geometries. Physical Review A 101 (2020).\n\n\n\nC. Gerry and P. Knight. Introductory Quantum Optics (Cambridge University Press, 2004).\n\n\n\n","category":"page"},{"location":"time_delay/#Non-Markovian-dynamics","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"","category":"section"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"Non-Markovian dynamics or memory effects can arise in waveguide QED systems when the emitted light is reflected back into the system or when considering two spatially separated emitters. Waveguide systems with memory effects constitute a challenging class of problems because knowledge of the emitted field is inherently required to capture the correct feedback. In the WaveguideQED framework, we describe the entirety of the emitted field, which enables a straightforward treatment of memory effects, which we showcase below.","category":"page"},{"location":"time_delay/#feedback","page":"Non-Markovian dynamics","title":"Waveguide and Mirror","text":"","category":"section"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"As an example of a system with memory effects, we consider a Semi-Infinite Waveguide terminating with a mirror in one end, as also depicted below. The mirror will here introduce a face shift phi, but also an excitation emitted in the left mode will, after a delay time of tau2, be reflected into the right mode and thus, after a total delay time of tau hit the emitter again.","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"(Image: alt text)","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"The left and right propagating modes are here symmetrical [5], and one can instead think of a single mode wrapping around the emitter. The waveguide is thus a \"horseshoe\", and the emitter couples to two points of the horseshoe. The two points are here seperated in time ensuring the feedback mechanism. This is also illustrated below.","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"(Image: alt text)","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"With this mental picture, there is only one propagating mode, and we describe the interaction through the Hamiltonian [6]:","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"beginequation\nH_k = mathrme^i phi sqrtgamma2Delta t left( sigma^dagger w_k + sigma w_k^dagger right) + sqrtgamma2Delta t left( sigma^dagger w_k+tildetau + sigma w_k+tildetau^dagger right)\nendequation","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"where tildetau = tauDelta t is the index necessary to introduce a time-delay of tau between the emission and reabsorption. Note that it is the operator w_k+tildetau that never \"sees\" the emitted photon again (thus corresponding to the left propagating mode in the first figure, whereas the operator w_k experiences the emitted photon from tildetau time steps ago (and thus corresponds to the right propagating mode).  w_k^dagger and w_k thus carry the phase factor mathrme^i phi from the mirror.","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"This type of Hamiltonian is easily described in the WaveguideQED framework. We can here create \"delayed\" operators that address time bins at a delayed time, thus corresponding to w_k+tildetau. This can be done with the keyword delay when creating the operator that determines how many bins the delay should be. The value delay should therefore be an integer corresponding to tildetau = tauDelta t. In the following, we define w_k+tildetau as w_delayed:","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"using WaveguideQED #hide\nusing QuantumOptics #hide\ntimes = 0:0.1:11\ndt = times[2]-times[1]\nbw = WaveguideBasis(1,times)\n\ndelay_time = 1\nw_delayed = destroy(bw;delay=delay_time/dt)\nwd_delayed = create(bw;delay=delay_time/dt)\nnothing #hide","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"The delayed operators are just normal WaveguideOperators addressing different time-bins and can, therefore, effortlessly be combined with the operators of the emitter:","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"be = FockBasis(1)\nsdw_delayed = create(be) ⊗ w_delayed\nwds_delayed = destroy(be) ⊗ wd_delayed\nnothing #hide","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"We can then create the non-delayed operators. We also define the Hamiltonian with a leakage rate of gamma = 1 and a mirror phase of pi:","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"gamma = 1\nphi = pi\n\nsdw = create(be) ⊗ destroy(bw)\nwds = destroy(be) ⊗ create(bw)\n\nH_pi = exp(im*phi)*sqrt(gamma/2/dt)*(sdw+wds)+sqrt(gamma/2/dt)*(sdw_delayed+wds_delayed)\nnothing #hide","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"Considering then how an initially excited emitter population decays, we create the expectation function ne_exp returning the emitter population and define the initial state. ","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"sd = create(be) ⊗ identityoperator(bw)\ns = destroy(be) ⊗ identityoperator(bw)\nn = sd*s\nfunction ne_exp(time,psi)\n    expect(n,psi)\nend\n\npsi_initial = fockstate(be,1) ⊗ zerophoton(bw)\nnothing #hide","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"Finally, we can solve the dynamics of the system and plot them.","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"_,ne_pi = waveguide_evolution(times, psi_initial, H_pi,fout=ne_exp)\nnothing #hide","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"using PyPlot #hide\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,real.(ne_pi),\"r-\")\nax.set_xlabel(L\"time [$1/\\gamma$]\")\nax.set_ylabel(\"Population\")\nplt.tight_layout() #hide\nplt.savefig(\"feedback_pi.svg\") #hide\nnothing #hide","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"(Image: alt text)","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"Here, we observe excitation trapping, where destructive interference from the mirror phase, prevents any excitation from going to the right after the initial feedback loop (notice the kink around t=1). This is a typical effect observed in these feedback systems, see [5]. Note that we observe an artifact in the simulation from t=10 to t=11 because the delayed operators are trying to address bins in the future which do not exist. To prevent such spurious results from appearing we can instead simulate for a shorter time such that the delay of the operators never exceed the time-bins over which the waveguide basis is defined. We illustrate this in the following by considering a mirror phase of phi =0 and only simulate until t=10:","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"phi = 0\nH_zero = exp(im*phi)*sqrt(gamma/2/dt)*(sdw+wds)+sqrt(gamma/2/dt)*(sdw_delayed+wds_delayed)\n\ntimes_sim = 0:0.1:10\n_,ne_0 = waveguide_evolution(times_sim, psi_initial, H_zero,fout=ne_exp)\nnothing #hide","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"This gives the plot:","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"fig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times_sim,real.(ne_pi[1:end-10]),\"r-\",label=L\"$\\phi = \\pi, \\ \\ \\ \\tau= 1$\")\nax.plot(times_sim,real.(ne_0),\"b-\",label=L\"$\\phi = 0, \\ \\ \\ \\tau= 1$\")\nax.plot(times_sim,real.(exp.(-times_sim)),\"k--\",label=L\"$\\tau= \\infty$\")\nax.set_xlabel(L\"time [$1/\\gamma$]\")\nax.set_ylabel(\"Population\")\nax.legend()\nplt.tight_layout() #hide\nplt.savefig(\"feedback_0.svg\") #hide\nnothing #hide","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"(Image: alt text)","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"For comparison, we here also plotteds an exponential decay with the rate gamma which corresponds to an infinite delay time. We see that for phi=0 we have constructive interference for the excitation going to the right and the population of the emitter decays faster than had there been no feedback.","category":"page"},{"location":"time_delay/#emitters","page":"Non-Markovian dynamics","title":"Spatially separated emitters","text":"","category":"section"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"Another interesting configuration to investigate is two spatially seperated emitters. If the separation between the emitters tau is comparable to the emission time 1gamma, then a full description of the waveguide state is necessary. A sketch of the considered system can be seen here:","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"(Image: alt text)","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"An emission from emitter A thus arrives at emitter B via the waveguide after tau time and vice versa. We can represent this in the Waveguide.jl formalism as a looped conveyor belt, where the two emitters interact with the waveguide or conveyor belt at two different times/places. This is illustrated below:","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"(Image: alt text)","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"We can create such a loop by using delayed operators. This way, the two emitters interact with the same waveguide in different time bins. The waveguide operators, per default, loop around themselves, and thus, by placing the delayed emitter exactly in the middle of the waveguide state, we recreate the loop above. This is also illustrated here:","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"(Image: alt text)","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"Here, the looping mechanism is illustrated as \"portals\" that move the waveguide state's last box to the waveguide's beginning whenever the end is reached due to the progression of time. We thus create a waveguide basis with a length of 2 tau and a set of waveguide operators which are delayed by tau:","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"using QuantumOptics #hide\nusing WaveguideQED #hide\nusing LinearAlgebra #hide\nusing PyPlot #hide\n\ntau = 10\ndt = 0.1\ntimes = 0:dt:2*tau+dt\nbw = WaveguideBasis(1, times) #waveguide basis\nbe = FockBasis(1) #emitter basis\n\n#Defining operators\nw = destroy(bw)\nwd = create(bw)\nw_tau = destroy(bw; delay=tau/dt+1)#Delay of tau\nwd_tau = create(bw; delay=tau/dt+1)#Delay of tau\nsd = create(be) #Emitter operator\ns = destroy(be) #Emitter operator\nIw = identityoperator(bw) #Identityoperator\nIe = identityoperator(be) #Identityoperator\nnothing #hide","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"We can then create the Hamiltonian, where emitter A interacts with the not-delayed operators and emitter B with the delayed operators. We also create the expectation value operators here: ","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"γ = 1\nH_e1 = im*sqrt(γ/dt)*(sd⊗Ie⊗w - s⊗Ie⊗wd) \nH_e2 = im*sqrt(γ/dt)*(Ie⊗sd⊗w_tau - Ie⊗s⊗wd_tau) \nH = H_e1 + H_e2\n\nne_a = (sd*s)⊗Ie⊗Iw\nne_b = Ie⊗(sd*s)⊗Iw\nnw = Ie⊗Ie⊗(wd*w)\nfunction expval(time, psi)\n  expect(ne_a, psi), expect(ne_b, psi), expect_waveguide(nw, psi)\nend\nnothing #hide","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"Finally, we can simulate the emission of a photon from emitter A, which, after a delay, impinges on emitter B:","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"times_sim = 0:dt:2*tau\nψ = fockstate(be, 1) ⊗ fockstate(be, 0) ⊗ zerophoton(bw)\nψ, e1, e2, ew = waveguide_evolution(times_sim, ψ, H, fout=expval)\n\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times_sim, abs.(e1), label=\"Emitter A\")\nax.plot(times_sim, abs.(e2), label=\"Emitter B\")\nax.plot(times_sim, abs.(ew), label=\"Waveguide\")\nax.set_xlabel(L\"Time [$1/\\gamma$]\")\nax.set_ylabel(\"Population\")\ntight_layout()\nax.legend()\nsavefig(\"e1_excited.svg\") #hide","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"(Image: alt text)","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"In the above, we see emitter A decay and emitter B absorps the emitted photon, albeit not entirely. In reality, part of the incoming pulse from emitter A will reflect, and part of it will be absorbed. This means that if we run the simulation for a longer period, we will see emitter A being excited before emitter B is finished emitting. We can show this by extending the simulation time to 6 tau:","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"times_sim = 0:dt:8*tau\nψ = fockstate(be, 1) ⊗ fockstate(be, 0) ⊗ zerophoton(bw)\nψ, e1, e2, ew = waveguide_evolution(times_sim, ψ, H, fout=expval)\n\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times_sim, abs.(e1), label=\"Emitter A\")\nax.plot(times_sim, abs.(e2), label=\"Emitter B\")\nax.plot(times_sim, abs.(ew), label=\"Waveguide\")\nax.set_xlabel(L\"Time [$1/\\gamma$]\")\nax.set_ylabel(\"Expectation Value\")\ntight_layout()\nax.legend()\nsavefig(\"e1_excited_slushing.svg\") #hide","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"(Image: alt text)","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"Here, we see the pulse doing multiple roundtrips, and the excitation of the emitters gets more and more complicated as reflections and reflections of reflections interfere. We see that as more round trips are completed, there is a simultaneous excitation of emitter A and B, indicating the non-trivial nature of the feedback loop. This gets even more complicated if one considers a lifetime of the emitters 1gamma that is longer than the delay 1tau.","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"One could also consider both emitters being excited in the beginning. This is done by allowing the waveguide to have two photons in it and changing the initial state. However, if there is no difference between the emitters, we will just see a completely symmetric excitation of them both, as the photons bounce back and forth. In the following, we thus consider two different decay rates of the emitters:","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"bw = WaveguideBasis(2, times) #waveguide basis with twophotons\nbe = FockBasis(1) #hide\nwd = create(bw) #hide\nwd_tau = create(bw; delay=tau/dt+1) #hide\nw = destroy(bw) #hide\nw_tau = destroy(bw; delay=tau/dt+1) #hide\nIw = identityoperator(bw) #hide\nne_a = (sd*s)⊗Ie⊗Iw #hide\nne_b = Ie⊗(sd*s)⊗Iw #hide\nnw = Ie⊗Ie⊗(wd*w) #hide\nfunction expval(time, psi) #hide\n  expect(ne_a, psi), expect(ne_b, psi), expect_waveguide(nw, psi) #hide\nend #hide\n\nγ = 1\nH_e1 = im*sqrt(γ/dt)*(sd⊗Ie⊗w - s⊗Ie⊗wd)\nH_e2 = im*sqrt(γ/dt/2)*(Ie⊗sd⊗w_tau - Ie⊗s⊗wd_tau)\nH = H_e1 + H_e2\n\n\ntimes_sim = 0:dt:6*tau\nψ = fockstate(be, 1) ⊗ fockstate(be, 1) ⊗ zerophoton(bw)\nψ, e1, e2, ew = waveguide_evolution(times_sim, ψ, H, fout=expval)\n\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times_sim, abs.(e1), label=\"Emitter A\")\nax.plot(times_sim, abs.(e2), label=\"Emitter B\")\nax.plot(times_sim, abs.(ew), label=\"Waveguide\")\nax.set_xlabel(L\"Time [$1/\\gamma$]\")\nax.set_ylabel(\"Expectation Value\")\ntight_layout()\nax.legend()\nsavefig(\"both_excited.svg\") #hide","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"(Image: alt text)","category":"page"},{"location":"time_delay/","page":"Non-Markovian dynamics","title":"Non-Markovian dynamics","text":"Here, we see that emitter A, which has a larger decay rate than emitter B, quickly decays so that emitter B is reexcited before it is fully de-excited. Afterward, the evolution quickly grows complicated due to the multiple scattering events. ","category":"page"},{"location":"example_lodahl/#Scattering-on-a-two-level-system","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"","category":"section"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"In the following, we show that with our framework, we can reproduce the theoretical results obtained in Le Jeannic, et al. Nat. Phys. 18, 1191–1195 (2022)","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"In many of the examples considered so far, we only consider a single waveguide that serves as both input and output, thus only allowing for only one-sided cavities or quantum systems at the end of a waveguide. A more realistic scenario is having a waveguide with a quantum system in the middle. Here an incoming waveguide carrying an excitation could scatter on the quantum system, and one would have excitations going away from the quantum system in both the first and latter part of the waveguide, as illustrated here:[1]","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"[1]: [3]","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"(Image: `alt text`)","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"A way to model this scenario is to have two waveguides: a waveguide to the left and the right, describing the first half of the waveguide and the latter half. For this, we use WaveguideBasis but with an extra argument specifying that we need two waveguides (see Multiple Waveguides for an introduction). We initialize WaveguideBasis with two waveguides and a basis for the atom (note that a fockbasis with only one excitation allowed is the same as a two-level-system):","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"using WaveguideQED #hide\nusing QuantumOptics #hide\ntimes = 0:0.1:10\ndt = times[2] - times[1]\nbw = WaveguideBasis(2,2,times)\nbe = FockBasis(1)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"We then define the operators for the interaction between atom and waveguide as (notice the second argument in create(bw,1) that defines which waveguide we are addressing):","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"wdLa = create(bw,1) ⊗ destroy(be)\nadwL = destroy(bw,1) ⊗ create(be)\nwdRa = create(bw,2) ⊗ destroy(be)\nadwR = destroy(bw,2) ⊗ create(be)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"where mathrmwdLa = w_L ^dagger a, mathrmwdRa = w_R ^dagger a, mathrmadwL = w_L  a^dagger, and mathrmadwR = w_R  a^dagger. In this example, we, however, also need an interaction between the waveguides. Therefore we define the creation and annihilation operators:","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"wdL = create(bw,1) ⊗ identityoperator(be)\nwL = destroy(bw,1) ⊗ identityoperator(be)\nwdR = create(bw,2) ⊗ identityoperator(be)\nwR = destroy(bw,2) ⊗ identityoperator(be)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"The interaction should carry over the momentum of the left waveguide into the waveguide on the right, and the interaction should therefore model a SWAP gate. This corresponds to V = pi 2 and thus we have the interaction Hamiltonian:","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"V = pi/2\nκ1 = 1\nκ2 = 1\nH = im*sqrt(κ1/dt)*(adwL-wdLa) + im*sqrt(κ2/dt)*(wdRa-adwR) + V/dt *(wdR*wL + wdL* wR)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"We can now study how single or two-photon states scatter on the atom. We define the initial one-photon or two-photon Gaussian state and solve it using the defined Hamiltonian:","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"ξ₁(t1,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t1-t0)^2/σ^2)\nξ₂(t1,t2,σ1,σ2,t0) = ξ₁(t1,σ1,t0) * ξ₁(t2,σ2,t0) \nw = 1\nt0 = 5\nψ1 = onephoton(bw,1,ξ₁,w,t0) ⊗ fockstate(be,0)\nψ2 = twophoton(bw,1,ξ₂,w,w,t0) ⊗ fockstate(be,0)\nψScat1 = waveguide_evolution(times,ψ1,H)\nψScat2 = waveguide_evolution(times,ψ2,H)\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"Viewing the scattered states is then done using TwoPhotonView and the index for the corresponding waveguide. Giving two indices returns instead the combined single photon state in both waveguides sum_jk ket1_j_1 ket1_k_2:","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"ψ2LeftScat = TwoPhotonView(ψScat2,1,[:,1])\nψ2RightScat = TwoPhotonView(ψScat2,2,[:,1])\nψ2LeftRightScat = TwoPhotonView(ψScat2,2,1,[:,1])\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"For the single-photon states, we have to calculate the two-time scattered distribution as:","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"ψ1LeftScat = zeros(ComplexF64,(length(times),length(times)))\nψ1RightScat = zeros(ComplexF64,(length(times),length(times)))\nψ1LeftRightScat = zeros(ComplexF64,(length(times),length(times)))\nψ1Right = OnePhotonView(ψScat1,2,[:,1])\nψ1Left = OnePhotonView(ψScat1,1,[:,1])\n\nfor i in eachindex(times)\n    for j in eachindex(times)\n        ψ1LeftScat[i,j] = ψ1Left[i]*ψ1Left[j]\n        ψ1RightScat[i,j] = ψ1Right[i]*ψ1Right[j]\n        ψ1LeftRightScat[i,j] = ψ1Left[i]*ψ1Right[j]\n    end\nend\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"Finally, we can plot the scattered wavefunctions, and we note that this matches Fig. 3 in Ref.[1]:","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"using PyPlot; #hide\nrcParams = PyPlot.PyDict(PyPlot.matplotlib.\"rcParams\") #hide\nrcParams[\"font.size\"] = 20 #hide\nrcParams[\"font.family\"] = \"serif\" #hide\nrcParams[\"mathtext.fontset\"] =\"cm\" #hide\nfig,axs = subplots(3,2,figsize=(6,9))\nplot_list = [ψ2RightScat,ψ2LeftScat,ψ2LeftRightScat,ψ1RightScat,ψ1LeftScat,ψ1LeftRightScat]\nfor (i,ax) in enumerate(axs)\n    plot_twophoton!(ax,plot_list[i],times)\nend\naxs[1].set_ylabel(\"\\$C^{RR}\\$ \\n t2 [a.u]\")\naxs[2].set_ylabel(\"\\$C^{LL}\\$ \\n t2 [a.u]\")\naxs[3].set_ylabel(\"\\$C^{LR}\\$ \\n t2 [a.u]\")\naxs[3].set_xlabel(\"t1 [a.u]\")\naxs[6].set_xlabel(\"t1 [a.u]\")\nplt.tight_layout()\nplt.savefig(\"lodahl_fig3.svg\") #hide\nnothing #hide","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"(Image: lodahl)","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"If we consider the single photon state, we can also visualize the temporal evolution as:","category":"page"},{"location":"example_lodahl/","page":"Scattering on a two-level system","title":"Scattering on a two-level system","text":"(Image: alt text)","category":"page"},{"location":"multiplewaveguides_v2/#multiple","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"","category":"section"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"In the tutorial, we considered one waveguide containing one or two waveguides. In WaveguideQED, we can also consider problems where we have multiple waveguides or equivalently multiple waveguide modes. We can create a waveguide basis containing two photons and two waveguides with:","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"using WaveguideQED #hide\nusing QuantumOptics #hide\ntimes = 0:0.1:10\ndt = times[2] - times[1]\nNPhotons = 2\nNWaveguides = 2\nbw = WaveguideBasis(NPhotons,NWaveguides,times)\nnothing #hide","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"info: WaveguideBasis(2,2,times) vs. Waveguide $\\otimes$ Waveguide\nInstead of using the custom basis for handling two waveguides, one could instead just do a tensor product between two waveguides basis. This naive approach would look something like:times = 0:0.1:10\nbw = WaveguideBasis(2,times)\nBtotal = bw ⊗ bwHowever, in the above example, the Hilbert space is of size: 27.594.009!!! What happened? We are now storing waveguide states of the type ket1_k1_j_1ket1_l1_m_2, that is two photons in each waveguide. But we wanted to only store up to two excitations and thus there is no possibility of having these states. Instead, we can exploit that only a total of two excitations are present simultaneously in the system. For this, we use the custom basis WaveguideBasis with an additional input stating the number of waveguides:bw = WaveguideBasis(2,2,times)The Hilbert space is now of size: 20706. This is still a large Hilbert space, but it is three orders of magnitude smaller than the naive approach as it only scales as propto N^2 as compared to propto N^4 where N is the number of time-bins.. ","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"We can then create the annihilation and creation operators for each waveguide by providing an index to destroy and create.","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"wd1 = create(bw,1)\nw1 = destroy(bw,1)\nwd2 = create(bw,2) \nw2 = destroy(bw,2)\nnothing #hide","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"Here wd1 creates a photon in waveguide mode 1: w_k1^dagger ketemptyset_1 ketemptyset_2 = ket1_k_1 ketemptyset_2, and equivalently wd2: w_k2^dagger ketemptyset_1 ketemptyset_2 = ketemptyset_1 ket1_k_2. ket1_k_i here denotes an excitation in time-bin k in waveguide i.   ","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"Similarly, if we want to create a one-photon state in waveguide 1 or 2 we give onephoton an extra waveguide index:","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nw_idx = 1\nψ_single_1 = onephoton(bw,w_idx,ξ,2,5)\n\nw_idx = 2\nψ_single_2 = onephoton(bw,w_idx,ξ,2,5)\nnothing #hide","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"where ψ_single_1 here denotes the state: ketpsi_1 = sum_k sqrtDelta t xi(t_k) w_k1^dagger ketemptyset  otimes ketemptyset and ψ_single_2 equivalently ketpsi_2 = ketemptyset otimes sum_k sqrtDelta t xi(t_k) w_k2^dagger ketemptyset. We can also define two-photons states with:","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"ξ2(t1,t2,σ,t0) = ξ(t1,σ,t0)*ξ(t2,σ,t0)\nw_idx = 1\nψ_double_1 = twophoton(bw,w_idx,ξ2,2,5)/sqrt(2)\n\nw_idx = 2\nψ_double_2 = twophoton(bw,w_idx,ξ2,2,5)/sqrt(2)\nnothing #hide","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"We can even describe a simultaneous excitation in both waveguide states like ket1_i_1ket1_j _2 by providing two indices:","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"ψ_single_1_and_2 = twophoton(bw,[1,2],ξ2,2,5)\nnothing #hide","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"Note the absence of 1sqrt2 when defining a state with one photon in each waveguide. ","category":"page"},{"location":"multiplewaveguides_v2/#lodahl","page":"Multiple Waveguides","title":"Scattering on two-level system","text":"","category":"section"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"As an example of a system with multiple waveguide modes, we consider a two-level system coupled with two directional waveguide modes; a left and a right propagating mode. A sketch of the system can be seen below here:","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"(Image: `alt text`)","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"Such a system is also considered experimentally in Le Jeannic, et al. Nat. Phys. 18, 1191–1195 (2022) and we here reproduce the theoretical results shown in the paper. The emitter here couples equally to the two waveguide modes with a total rate of gamma, the Hamiltonian is here: ","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"H = i sqrtgamma2Delta t ( a^dagger w_1 - a w_1^dagger) + i sqrtgamma2Delta t ( a^dagger w_2 - a w_2^dagger)","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"We can define this Hamiltonian, by creating the basis of the emitter and combining it with the waveguide operators:","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"be = FockBasis(1)\na = destroy(be)\nad = create(be)\nγ = 1\nH = im*sqrt(γ/2/dt)*( ad ⊗ w1 - a ⊗ wd1  ) + im*sqrt(γ/2/dt)*( ad ⊗ w2 - a ⊗ wd2  )\nnothing #hide","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"In the above, we denote waveguide 1 as the right propagating mode and waveguide 2 as the left propagating mode.","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"We can now study how single or two-photon states scatter on the emitter. We define the initial one-photon or two-photon Gaussian state and solve it using the defined Hamiltonian:","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"ξ₁(t1,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t1-t0)^2/σ^2)\nξ₂(t1,t2,σ,t0) = ξ₁(t1,σ,t0) * ξ₁(t2,σ,t0) \nw = 1\nt0 = 5\nψ1 = fockstate(be,0) ⊗ onephoton(bw,1,ξ₁,w,t0)\nψ2 = fockstate(be,0) ⊗ twophoton(bw,1,ξ₂,w,t0)/sqrt(2)\nψScat1 = waveguide_evolution(times,ψ1,H)\nψScat2 = waveguide_evolution(times,ψ2,H)\nnothing #hide","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"Viewing the scattered states is then done using TwoPhotonView and the index for the corresponding waveguide. Giving two indices returns the combined single photon state in both waveguides sum_jk ket1_j_1 ket1_k_2:","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"ψ2RightScat = TwoPhotonView(ψScat2,1,[1,:])\nψ2LeftScat = TwoPhotonView(ψScat2,2,[1,:])\nψ2LeftRightScat = TwoPhotonView(ψScat2,2,1,[1,:])\nnothing #hide","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"We now want to compare the difference between a two-photon state scattering on the emitter and a single-photon state scattering. The scattered two-photon wavefunction can be expressed as xi^(2)(t_1t_2) = xi^(1)(t_1)xi^(1)(t_2) + N(t_1t_2), where xi^(1)(t) is the scattered single-photon state and N(t_1t_2) is the bound-state or non-linear contribution of the interaction with the emitter (stimulated emission). Thus, we compare the scattered two-photon state with the product of the scattered single-photon state. We thus calculate the two-time scattered distribution as:","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"ψ1RightScat = zeros(ComplexF64,(length(times),length(times)))\nψ1LeftScat = zeros(ComplexF64,(length(times),length(times)))\nψ1LeftRightScat = zeros(ComplexF64,(length(times),length(times)))\nψ1Right = OnePhotonView(ψScat1,1,[1,:])\nψ1Left = OnePhotonView(ψScat1,2,[1,:])\n\nfor i in eachindex(times)\n    for j in eachindex(times)\n        ψ1RightScat[i,j] = ψ1Right[i]*ψ1Right[j]\n        ψ1LeftScat[i,j] = ψ1Left[i]*ψ1Left[j]\n        ψ1LeftRightScat[i,j] = ψ1Left[i]*ψ1Right[j]\n    end\nend\nnothing #hide","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"Finally, we can plot the scattered wavefunctions, and we note that this matches Fig. 3 in Ref.[1]:","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"using PyPlot; #hide\nrcParams = PyPlot.PyDict(PyPlot.matplotlib.\"rcParams\") #hide\nrcParams[\"font.size\"] = 20 #hide\nrcParams[\"font.family\"] = \"serif\" #hide\nrcParams[\"mathtext.fontset\"] =\"cm\" #hide\nfig,axs = subplots(3,2,figsize=(6,9))\nplot_list = [ψ2RightScat,ψ2LeftScat,ψ2LeftRightScat,ψ1RightScat,ψ1LeftScat,ψ1LeftRightScat]\nfor (i,ax) in enumerate(axs)\n    plot_twophoton!(ax,plot_list[i],times)\nend\naxs[1].set_ylabel(\"\\$C^{RR}\\$ \\n t2 [a.u]\")\naxs[2].set_ylabel(\"\\$C^{LL}\\$ \\n t2 [a.u]\")\naxs[3].set_ylabel(\"\\$C^{LR}\\$ \\n t2 [a.u]\")\naxs[3].set_xlabel(\"t1 [a.u]\")\naxs[6].set_xlabel(\"t1 [a.u]\")\nplt.tight_layout()\nplt.savefig(\"lodahl_fig3.svg\") #hide\nnothing #hide","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"(Image: lodahl)","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"If we consider the single photon state, we can also visualize the temporal evolution as:","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"(Image: alt text)","category":"page"},{"location":"multiplewaveguides_v2/","page":"Multiple Waveguides","title":"Multiple Waveguides","text":"[1]: [3]","category":"page"},{"location":"gpu_support/#GPU-Support","page":"GPU Support","title":"GPU Support","text":"","category":"section"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"For particularly large system sizes there can be substantial computational gains by running the simulations on a Graphical Processing Unit (GPU). In WaveguideQED.jl, to run on a GPU, all operators and states (kets) should be \"put\" on the GPU, meaning they should be converted into CUDA arrays. The WaveguideOperators will then dispatch on custom written GPU kernels, which will significantly speed up the computational time for large systems. The GPU code is written using CUDA.jl and it should be installed before the following code will work, see CUDA.jl for details.  In the following, we provide an example of how to utilize a GPU.","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"To convert operators and kets to GPU arrays we define the following convinience functions:","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"using CUDA #Load CUDA\n\nfunction to_gpu(a::Operator)\n    data = cu(map(ComplexF32,a.data))\n    gpu_operator = Operator(a.basis_l,a.basis_r,data)\n    return gpu_operator\nend\n\nfunction to_gpu(a::Ket)\n    data = cu(map(ComplexF32,a.data))\n    gpu_ket = Ket(a.basis,data)\n    return gpu_ket\nend","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"We then define the system, its operators, and initial state:","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"dt = 0.01\ntimes = 0:dt:10\nbw = WaveguideBasis(2, times)\nbc = FockBasis(2)\n\n\na = destroy(bc)\nad = create(bc)\n\nw = destroy(bw)\nwd = create(bw)\n\nξ₁(t1,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t1-t0)^2/σ^2)\nξ₂(t1,t2,σ1,σ2,t0) = ξ₁(t1,σ1,t0) * ξ₁(t2,σ2,t0) \nwidth = 1\nt0 = 5\nψ = fockstate(bc,0) ⊗ twophoton(bw,1,ξ₂,width,width,t0)","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"WaveguideOperators does not need to be converted to a gpu, since they are just symbolic objects representing the action of the waveguide operator, but all system operators and all states need to be converted. In the following, we thus convert the operators and initial states to gpu operators:","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"a_gpu = to_gpu(a)\nad_gpu = to_gpu(ad)\nψ_gpu = to_gpu(ψ)","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"It is then simple to combine operators to run simulations on the gpu:","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"γ = 1\nadw_gpu = ad_gpu ⊗ w\nwda_gpu = a_gpu ⊗ wd\nH_gpu =  sqrt(γ/dt)*(wda_gpu+ adw_gpu)\n\nψ_out = waveguide_evolution(times,ψ_gpu,H_gpu)","category":"page"},{"location":"gpu_support/","page":"GPU Support","title":"GPU Support","text":"The above simulation takes around 30s using an Nvidia 3060Ti GPU compared to around 900s using a regular CPU. More gains could be expected with a more high-performance GPU and for larger systems. ","category":"page"},{"location":"detection/#BStutorial","page":"Detection and Projections","title":"Detection and Projections","text":"","category":"section"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"A beamsplitter is a partly reflective, partly transmissive mirror that splits up an incoming photon, as depicted here. ","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"(Image: beamsplitter)","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Assuming that the beamsplitter is equal (50% transmission and 50% reflection) and that we have only a single photon in one of waveguides impinging on the beamsplitter, the photon will go to detector plus 50% of the time and detector minus the other 50% of the time. This can be modeled in WaveguideQED.jl using LazyTensorKet and Detector. We start by creating the two input waveguides.   ","category":"page"},{"location":"detection/#Background-Theory","page":"Detection and Projections","title":"Background Theory","text":"","category":"section"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Two photons impinging on a beamsplitter is a classic example of destructive and constructive interference. If the two photons are indistinguishable, they will always appear in pairs on the other side of the beamsplitter. That is the following scenario:  ","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"(Image: beamsplitter)","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"However, what happens if the two photons have a slight mismatch in frequency or their temporal distribution, and how do we model this? Assuming the beamsplitter is 50/50 the beamsplitter transformation is[1]  : w_a rightarrow (w_c + w_d)sqrt(2) and w_b rightarrow (w_c - w_d)sqrt(2), where w_k is the annihilation operator for waveguide k=abcd. A one photon continuous fockstate in waveguide a and b with wavefunction xi_a(t) and xi_b(t) has the combined state:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"beginalign*\nketpsi_ab = ketpsi_a otimes ketpsi_b =  int_t_0^t_end mathrmdt  xi_a(t) w_a^dagger(t) ket0_a otimes int_t_0^t_end mathrmdt  xi_b(t) w_b^dagger(t) ket0_b \n int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) w_a^dagger(t)  w_b^dagger(t) ket0_aket0_b\nendalign*","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Using the beamsplitter transformation, we thus have the following state after the two photons have interfered with the beamsplitter:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"beginalign*\nketpsi_ab xrightarrowBS frac12  int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) (w_c^dagger(t) + w_d^dagger(t))  (w_c^dagger(t) - w_d^dagger(t)) ket0_aket0_b \n=  frac12  int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) left  w_c^dagger(t) w_c^dagger(t) + w_d^dagger(t)w_c^dagger(t) - w_c^dagger(t)w_d^dagger(t) - w_d^dagger(t)w_d^dagger(t) right  ket0_cket0_d \n= frac12 left ( W_c^dagger(xi_a) W_c^dagger(xi_b) ket0_c - W_d^dagger(xi_a) W_d^dagger(xi_b) ket0_d + int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt left  xi_a(t)xi_b(t) - xi_a(t)xi_b(t) right ket1_cket1_d right)\nendalign*","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"where we introduced W_cd^dagger(xi_a) W_cd^dagger(xi_b) ket0_cd = int_t_0^t_end mathrmdt int_t_0^t_end mathrmdt xi_a(t)xi_b(t) w_cd^dagger(t) w_cd^dagger(t) ket0_cd. W_cd^dagger(xi_a) W_cd^dagger(xi_b) ket0_cd thus corresponds to both photons going into the same direction. It is also evident that if xi_a(t)xi_b(t) - xi_a(t)xi_b(t) = 0 then we will have no photons in waveguide c and d simultaneously. This condition is exactly fulfilled if the photon in waveguide a is indistinguishable from the photon in waveguide b. This also means that if the photons ARE distinguishable, we will start to see photons occurring in waveguides c and d simultaneously. All this and more can be simulated in the code, and in the next section, we walk through how to set the above example up in the code.","category":"page"},{"location":"detection/#Beamsplitter-and-detection-in-WaveguideQED.jl","page":"Detection and Projections","title":"Beamsplitter and detection in WaveguideQED.jl","text":"","category":"section"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"In WaveguideQED.jl we create the two incoming photons in each of their respective waveguides and define the corresponding annihilation operators:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"using WaveguideQED #hide\nusing QuantumOptics #hide\ntimes = 0:0.1:20\nbw = WaveguideBasis(1,times)\nξfun(t,σ,t0) = complex(sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2))\nwaveguide_a = onephoton(bw,ξfun,1,10)\nwaveguide_b = onephoton(bw,ξfun,1,10)\nwa = destroy(bw)\nwb = destroy(bw)\nnothing #hide","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"We then combine the states of waveguide a and b in a lazy tensor structure (tensor product is never calculated, but the dimensions are inferred in subsequent calculations):","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"ψ_total = LazyTensorKet(waveguide_a,waveguide_b)\nnothing #hide","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Now we define Detector operators, which define the beamsplitter and subsequent detection operation. In the following mathrmDplus = D_+ = frac1sqrt2(w_a + w_b)  and mathrmDminus = D_- = frac1sqrt2(w_a - w_b)","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Dplus = Detector(wa/sqrt(2),wb/sqrt(2))\nDminus = Detector(wa/sqrt(2),-wb/sqrt(2))\nnothing #hide","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"The Detector applies the first operator (wa/sqrt(2)) to the first Ket in LazyTensorKet (waveguide_a) and the second operator ($\\pm $ wb/sqrt(2)) to the second Ket in LazyTensorKet (waveguide_b). The probability of detecting a photon in the detectors can then be calculated by:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"p_plus = Dplus * ψ_total\np_minus = Dminus * ψ_total","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"The returned probabilities are zero because there is no states that result in only ONE click at the detectors. Instead, we have to ask for the probability of detecting TWO photons:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"p_plus_plus = Dplus * Dplus * ψ_total\np_minus_minus = Dminus * Dminus * ψ_total","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Notice that we here asked what the probability of having a detection event in detector plus/minus and, subsequently, another detection event in detector plus/minus is. The output was 50 for both cases reflecting the above calculations where we would expect the two photons always come in pairs. As a consequence, the probability of having a click in detector plus and then in detector minus (or vice versa) is given as:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"p_plus_minus = Dplus * Dminus * ψ_total\np_minus_plus = Dminus * Dplus * ψ_total","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"As expected, the resulting probabilities are zero. If we instead displace the photons in time so that one is centered around t = 5 and another around t = 15 we get:","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"waveguide_a = onephoton(bw,ξfun,1,5);\nwaveguide_b = onephoton(bw,ξfun,1,15);\nψ_total = LazyTensorKet(waveguide_a,waveguide_b);\np_plus_plus = Dplus * Dplus * ψ_total\np_minus_minus = Dminus * Dminus * ψ_total\np_plus_minus = Dplus * Dminus * ψ_total\np_minus_plus = Dminus * Dplus * ψ_total","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"Thus we have an equal probability of detection events in the same detector and opposite detectors since the two photon-pulses are temporarily separated.","category":"page"},{"location":"detection/","page":"Detection and Projections","title":"Detection and Projections","text":"[1]: [14]","category":"page"},{"location":"input_output/#input","page":"Input-Output Relations","title":"Input-Output Relations","text":"","category":"section"},{"location":"input_output/#Theory","page":"Input-Output Relations","title":"Theory","text":"","category":"section"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"In waveguide QED systems, the waveguide modes themselves can often also interact. This interaction can happen due to e.g. a partially transmitting and reflecting element that scatters one waveguide mode into another. In the input-output formalism, this is described by a coupling matrix mathbfC. A perfectly balanced beamsplitter would thus have the coupling matrix mathbfC = 1sqrt2beginpmatrix 1  - i  -i  1 endpmatrix which relates the input waveguide modes with the output modes (output here referring to the mode after the interaction) by the following relation:","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"beginequation*\n    mathbfW_mathrmout = mathbfC mathbfW_mathrmin\nendequation*","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"where","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"beginequation*\n    mathbfW_in = beginpmatrix\n        w_in1(t)  w_in2(t)  vdots  w_inN(t)\n    endpmatrix         mathbfW_out = beginpmatrix\n    w_out1(t)  w_out2(t)  vdots  w_outN(t)\n    endpmatrix    \nendequation*","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"Are vectors containing each waveguide mode. More generally, when a local quantum system with the Hamiltonian H_s and creation and annihilation operators a and a^dagger is coupled to the waveguide it is shown in [4], that fundamental input-output relations can be derived from the Hamiltonian:","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"beginequation*\n    H= H_mathrms+ sum_i=1^N int d nu hbar nu w_i^dagger(nu) w_i(nu)+sum_i=1^N hbar sqrtgamma_i int fracd nusqrt2 pileft(w_i^dagger(nu) a+a^dagger w_i(nu)right) +sum_i neq j hbar V_i j int fracd nusqrt2 pi int fracd  nu^primesqrt2 pi w_i^dagger(nu) w_j(nu^prime)\nendequation*","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"where w_i(nu) is the annihilation operator for waveguide mode i with frequency nu, gamma_i is the coupling between the local system with Hamiltonian H_s and waveguide mode i, and V_ij =V_ji is the unitless coupling between waveguide modes. N is here the total number of waveguide modes. The resulting input-output relations depend on the evolution of the local system and thus become:","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"beginequation*\n    begingathered\n    fracdd t a=-ilefta H_mathrmcright-Sigma a+mathbfk^T mathbfW_mathrmin \n    mathbfW_text out (t)=mathbfC mathbfW_mathrmin(t)+a(t)mathbfd\n    endgathered\nendequation*","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"Here Sigma describes a self-energy correction due to the interaction with the waveguides, and mathbfk=mathbfd is the effective coupling between the waveguides and quantum system. All quantities depend on the waveguide coupling mathbfV and waveguide-system coupling mathbfGamma ","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"beginequation*\n    textbfV = beginpmatrix\n        0  V_12  cdots  V_1N \n        V_21  0  cdots  V_2N \n        vdots  vdots  ddots  vdots \n        V_N1  V_N2  cdots  0 \n    endpmatrix             mathbfGamma =  beginpmatrix\n        gamma_1 \n        gamma_2 \n        vdots \n        gamma_N\n    endpmatrix\nendequation*","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"as:","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"beginequation*\n    mathbfC equivleft(mathbfI-fraci2 mathbfVright)left(mathbfI+fraci2 mathbfVright)^-1 quad mathbfd = mathbfk equiv-ileft(mathbfI+fraci2 mathbfVright)^-1 mathbfGamma quad Sigma equiv frac12 mathbfGamma^Tleft(mathbfI+fraci2 mathbfVright)^-1 mathbfGamma \nendequation*","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"from this, it is evident that the coupling with the system mathbfk=mathbfd is not independent of the waveguide coupling mathbfV. As we shall see, this can be interpreted as the waveguide coupling mathbfV altering the local density of optical states and thus changing the coupling between the waveguides and the local system. In the time-bin formalism, we cannot simply simulate the Hamiltonian, since coupling between waveguide modes is not allowed in a collision picture. Instead, we can introduce an effective coupling and simulate the Hamiltonian:","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"beginequation*\n    H= tildeH_mathrms+ sum_i=1^N int d nu hbar nu w_i^dagger(nu) w_i(nu)+sum_i=1^N hbar int fracd nusqrt2 pileft(tildeGamma_i^* w_i^dagger(nu) a+ tildeGamma_i a^dagger w_i(nu)right)\nendequation*","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"where tildeGamma_i is the i'th element of mathbftildeGamma = (mathbfI + fraci2mathbfV)^-1 mathbfGamma and tildeH_c = H_c - imathrmIm Sigma a^dagger a is the normalized system Hamiltonian due to the self-energy correction (note only the imaginary part since the real part correction will be introduced from the renormalized coupling). The resulting input-out relations will from this Hamiltonian be:","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"beginalign*\n     fracdd t a= -ilefta tildeH_mathrmc right -mathrmRe(Sigma) a + tildemathbfk^T mathbfW_mathrmin \n     widetildemathbfW_text out (t)= mathbftildeC mathbfW_mathrmin(t)+a(t)tildemathbfd\nendalign*","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"where tildemathbfd = -i left(left(mathbfI+fraci2 mathbfVright)^-1 right)^* mathbfGamma, tildemathbfk = -i left(left(mathbfI+fraci2 mathbfVright)^-1 right) mathbfGamma, and tildemathbfC = mathbfI. Noticeably, the renormalized coupling tildemathbfC does not correspond to the original input-output relations, by multiplying widetildemathbfW_text out (t) with mathbfC we can restore the correct relations:","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"beginalign*\n fracdd t a= -ilefta tildeH_mathrmc right -mathrmRe(Sigma) a + tildemathbfk^T mathbfW_mathrmin \n mathbfCwidetildemathbfW_text out (t)= mathbfC mathbfW_mathrmin(t)+a(t)tildemathbfk\nendalign*","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"where we used that mathbfC mathbftilded = mathbftildek. In the time-bin picture, we can thus use the Hamiltonian:","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"beginequation*\n    H_k= H_mathrms+ sum_i=1^N hbar tildeGamma_i^* w_ki^dagger a+ tildeGamma_i a^dagger w_ki\nendequation*","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"to obtain kettildepsi_mathrmout = sum_i int widetildeW_outi^dagger ketemptyset otimes ketpsi_s1 where ketpsi_s1 is the system state after the simulation. To get the correct output state we then perform the transformation according to mathbfC such that: ","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"beginequation*\n    ketpsi_mathrmout = C^dagger kettildepsi_mathrmout = sum_ij int C_ij^dagger widetildeW_outi^dagger ketemptyset otimes ketpsi_s1 = sum_i int W_outi^dagger ketemptyset otimes ketpsi_s1\nendequation*","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"We here only show the case where the output state is a superposition of single-photon states, but this can be generalized to multiple-photon states (although this has not been implemented yet). In the following, we show how we can use the above to predict Fano-resonances in waveguide systems.","category":"page"},{"location":"input_output/#Waveguide-with-Partially-Transmitting-Element","page":"Input-Output Relations","title":"Waveguide with Partially Transmitting Element","text":"","category":"section"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"In the following, we consider a waveguide with two propagating modes (left and right) and a scattering element V that couples the two modes with each other. The waveguide is also coupled to a quantum emitter through a total decay rate of gamma meaning a coupling of gamma2 to each waveguide mode. A sketch of the system can be seen below: (Image: alt text) This is almost the system considered in Multiple Waveguides, except that we have now introduced the scattering element V.","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"As mentioned above, we can capture the dynamics of the system by renormalizing the coupling depending on the waveguide interaction V. This can be done automatically in WaveguideQED by giving a vector of the waveguide-emitter coupling, which in this case is: mathbfGamma = beginpmatrix gamma2  gamma2 endpmatrix and the desired waveguide coupling mathbfC. For example, if we want a fully reflecting element we would choose mathbfC = beginpmatrix 0  1  1  0  endpmatrix. The function effective_hamiltonian returns the renormalized Hamiltonian:","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"using WaveguideQED #hide\nusing QuantumOptics #hide\ntimes = 0:0.05:50\ndt = times[2] - times[1]\n\nbw = WaveguideBasis(1,2,times)\nbe = FockBasis(1)\n\n\nC = [0 -1.0im; -1.0im 0]\nγ=1\nG = [sqrt(γ/dt),sqrt(γ/dt)]\n\nH = effective_hamiltonian(bw,be,C,G)\nnothing #hide","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"With this, we can study the scattering of single photon pulse. In the following, we initialize the state and simulate the scattering.","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"\nξfun(t1,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t1-t0)^2/σ^2)\n\nψ_in = onephoton(bw,1,ξfun,1,5) ⊗ fockstate(be,0)\nψ_out_tilde = waveguide_evolution(times,ψ_in,H)\nnothing #hide","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"We now have obtained kettildepsi_mathrmout and we then apply the transformation of mathbfC to get ketpsi_mathrmout. This can be done with the WaveguideTransform operator:","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"C_transform = WaveguideTransform(bw,C) ⊗ identityoperator(be)\nψ_out = C_transform*ψ_out_tilde\nnothing #hide","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"Plotting the output state, we see that compared with the example in Multiple Waveguides the transmitted (right) and reflected mode (left) are interchanged due to the fully reflecting medium V:","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"using PyPlot #hide\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,abs.(OnePhotonView(ψ_out,1)).^2,\"r-\",label=\"Right\")\nax.plot(times,abs.(OnePhotonView(ψ_out,2)).^2,\"b-\",label=\"Left\")\nax.set_xlim(0,20)\nax.legend()\nplt.tight_layout()\nplt.savefig(\"inputoutput.svg\") #hide\nnothing #hide","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"(Image: alt text)","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"The shapes are qualitatively the same as in Multiple Waveguides but if we study the actual numbers, we will see that the effective emitter-waveguide coupling has been renormalized due to the scattering element. This is especially clear if we consider an initially excited emitter and its emission spectrum. In the following, we vary the waveguide coupling through V and see how the emission spectrum (Fourier transformation of the time-wavefunction xi(t)) changes. ","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"fig,ax = subplots(1,1,figsize=(9,4.5))\ncolor_plots = [\"red\",\"blue\",\"green\",\"black\",\"purple\",\"cyan\",\"darkorange\",\"darkblue\",\"darkgreen\"]\n\nVs = 0:0.3:2\nG = [sqrt(γ/dt),sqrt(γ/dt)]\nfor (i,V) in enumerate(Vs)\n\n    C_sweep,_ = WaveguideQED.io_relations_from_V([0 V;V 0],G)\n    H_sweep = effective_hamiltonian(bw,be,C_sweep,G)\n\n    psi_in = zerophoton(bw) ⊗ fockstate(be,1)\n    psi_out = waveguide_evolution(times,psi_in,H_sweep)\n    freq,spec = fftket(psi_out,1)\n    ax.plot(freq,2*pi*abs.(spec*(freq[2]-freq[1])).^2,ls=\"-\",color=color_plots[i],label=L\"$V=$\"*\"$(round(Vs[i],digits=2))\")\nend\nax.legend(loc=\"upper left\",fontsize=18)\nax.set_xlim(-4,4)\nax.set_xlabel(L\"$\\omega - \\omega_e \\ [\\gamma]$\")\nax.set_ylabel(L\"$S(w)$ [$\\gamma$]\")\nplt.tight_layout() #hide\nplt.savefig(\"emitter_lifetime.svg\") #hide\nnothing #hide","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"(Image: alt text)","category":"page"},{"location":"input_output/","page":"Input-Output Relations","title":"Input-Output Relations","text":"We can see that the frequency of the emission spectrum shift as we increase V but also the FWHM of the Lorentzian narrows due to an increase in the emitter lifetime (decrease in the effective emitter-waveguide coupling).","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/#WaveguideQED.CavityWaveguideAbsorption","page":"API","title":"WaveguideQED.CavityWaveguideAbsorption","text":"CavityWaveguideAbsorption{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous Cavity creation and Waveguide annihilation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.CavityWaveguideEmission","page":"API","title":"WaveguideQED.CavityWaveguideEmission","text":"CavityWaveguideEmission{B1,B2} <: CavityWaveguideOperator{B1,B2}\n\nStructure for fast simultaneous cavity annihilation and waveguide creation operator\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.CavityWaveguideOperator","page":"API","title":"WaveguideQED.CavityWaveguideOperator","text":"Abstract type used for operators on acting on a combined WaveguideBasis and cavity basis (FockBasis)\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.Detector","page":"API","title":"WaveguideQED.Detector","text":"Detector(wa,wb)\n\nDetector operation defined by giving waveguide annihilation operator wa and wb from two subsystems. wa acts on the first subsystem of a LazyTensorKet or LazySumKet and wb on the second.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.LazySumKet","page":"API","title":"WaveguideQED.LazySumKet","text":"LazySumKet(kets...)\n\nLazy sum of LazyTensorKets that is used to express entanglement between subsystems in LazyTensorKets. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.LazyTensorBra","page":"API","title":"WaveguideQED.LazyTensorBra","text":"LazyTensorBra(bras)\n\nLazy tensor product between bras. Used in functions for beamsplitter and subsequent detection.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.LazyTensorKet","page":"API","title":"WaveguideQED.LazyTensorKet","text":"LazyTensorKet(kets)\n\nLazy tensor product between kets. Used in functions for beamsplitter and subsequent detection.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.NLevelWaveguideOperator","page":"API","title":"WaveguideQED.NLevelWaveguideOperator","text":"NLevelWaveguideOperator{B1,B2} <: NWaveguideOperator{BL,BR}\n\nStructure for fast simultaneous N-level transition and waveguide operator. This operator combines a transition operator between levels in an N-level system with a waveguide operator.\n\nFields\n\nbasis_l::B1: Left basis\nbasis_r::B2: Right basis\nfactor::ComplexF64: Complex prefactor\nop::AbstractOperator: The waveguide operator\nloc: Location indices for the operator\nn_to::Int: Target level for the transition\nn_from::Int: Source level for the transition\nindexing::WaveguideIndexing: Indexing structure for efficient state vector multiplication\n\nExamples\n\n# Create a transition between levels 2 and 1 in an N-level system combined with a waveguide operator\nop = NLevelWaveguideOperator(basis_l, basis_r, 1.0, waveguide_op, [1,2], 2, 1)\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.OnePhotonView","page":"API","title":"WaveguideQED.OnePhotonView","text":"OnePhotonView{T} <: AbstractVector{T}\n\nStructure for viewing onephoton excitations in waveguides of the form W^dagger(xi) 0 rangle = int_t_0^t_end dt  xi(t) w_mathrmi^dagger(t) emptyset rangle where i is the index of the waveguide. See onephoton on how to create onephoton wavepackets and view_waveguide on how to index when there are multiple systems.\n\nExamples\n\nusing QuantumOptics;\ntimes = 0:1:10;\nbw = WaveguideBasis(1,times);\nψ1 = onephoton(bw,x->1,norm=false);\nOnePhotonView(ψ1) == ones(length(times))\n\nbc = FockBasis(2);\nψ1Cavity = fockstate(bc,2,norm=false) ⊗ ψ1;\nOnePhotonView(ψCavity,[3,:]) == ones(length(times))\n\nbw =  WaveguideBasis(1,3,times);\nψ2 = onephoton(bw,2,x->1,norm=false)\nOnePhotonView(ψ,2) == ones(length(times))\n\nψ2Cavity = fockstate(bc,2) ⊗ ψ2;\nOnePhotonView(ψ2Cavity,2,[3,:]) == ones(length(times))\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.OnePhotonView-Tuple{T} where T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T<:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis, QuantumInterface.SpinBasis}}}, Np}))","page":"API","title":"WaveguideQED.OnePhotonView","text":"OnePhotonView(ψ::T) where {T<:SingleWaveguideKet}\n\nψ contains only a single waveguide and no waveguide index is needed. No index of the system is provided and groundstate is assumed.  Thus returns OnePhotonView(ψ,index) with index = [1,:,1,...] with : at the location of the waveguide and 1 in every other position. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.OnePhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, Int64, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis, QuantumInterface.SpinBasis}}}, Np, Nw})), I<:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}","page":"API","title":"WaveguideQED.OnePhotonView","text":"OnePhotonView(ψ::T,WI::Int,index::I) where {T<:MultipleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\n\nψ contains only a multiple waveguides and waveguide index WI is needed. index should follow syntax outlined in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.OnePhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T<:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis, QuantumInterface.SpinBasis}}}, Np})), I<:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}","page":"API","title":"WaveguideQED.OnePhotonView","text":"OnePhotonView(ψ::T,index::I) where {T<:SingleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\n\nψ contains only a single waveguide and no waveguide index is needed. index should follow syntax outlined in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.OnePhotonView-Union{Tuple{T}, Tuple{T, Int64}} where T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis, QuantumInterface.SpinBasis}}}, Np, Nw}))","page":"API","title":"WaveguideQED.OnePhotonView","text":"OnePhotonView(ψ::T,WI::Int)  where {T<:MultipleWaveguideKet}\n\nψ contains only a multiple waveguides and waveguide index WI is needed. No index of the system is provided and groundstate is assumed (see view_waveguide). \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonTimestepView","page":"API","title":"WaveguideQED.TwoPhotonTimestepView","text":"TwoPhotonTimestepView{T}\n\nStructure for viewing slice along same times in twophoton state. Used in mul!. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.TwoPhotonView","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwophotonView{T} <: AbstractMatrix{T}\n\nStructure for viewing twophoton state of the form int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle where i and j are the indeces of the waveguide as matrix. See also twophoton and view_waveguide.\n\nExamples\n\nBasic viewing:\n\nusing LinearAlgebra; #hide\ntimes = 1:1:10;\nbw = WaveguideBasis(2,times);\nψ = twophoton(bw,(t1,t2)->1,norm=false);\nψview = TwoPhotonView(ψ);\nψview == ones((length(times),length(times)))\n\nViewing state combined with other basis:\n\nusing QuantumOptics;\nbc = FockBasis(2);\nψcombined = fockstate(bc,2) ⊗ ψ;\nψview = TwoPhotonView(ψcombined,[3,:]);\nψview == ones((length(times),length(times)))\n\nViewing twophoton state in waveguide 2 with multiple waveguides\n\nbw = WaveguideBasis(2,3,times)\nψ = twophoton(bw,2,(t1,t2)->1,norm=false);\nψview = TwoPhotonView(ψ,2);\nψview == ones((length(times),length(times)))\n\nViewing twophoton state in waveguide 2 with multiple waveguides combined with other basis:\n\nψcombined = fockstate(bc,2) ⊗ ψ;\nψview = TwoPhotonView(ψcombined,2,[3,:]);\nψview == ones((length(times),length(times)))\n\nViewing twophotons across waveguide 1 and 2\n\nbw = WaveguideBasis(2,3,times)\nψ = twophoton(bw,1,2,(t1,t2)->1,norm=false);\nψview = TwoPhotonView(ψ,1,2);\nψview == ones((length(times),length(times)))\n\nViewing twophotons across waveguide 1 and 2 combined with other basis:\n\nψcombined = fockstate(bc,2) ⊗ ψ;\nψview = TwoPhotonView(ψcombined,1,2,[3,:]);\nψview == ones((length(times),length(times)))\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.TwoPhotonView-Tuple{T} where T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T<:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis, QuantumInterface.SpinBasis}}}, Np}))","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T) where {T <: SingleWaveguideKet}\n\nState ψ only contains one waveguide and no index provided so groundstate is assumed. See view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{F}, Tuple{I}, Tuple{T}, Tuple{T, F, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis, QuantumInterface.SpinBasis}}}, Np, Nw})), I<:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}, F<:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,WI::F,index::I)  where {T<:MultipleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}},F<:Union{Vector{Int64},Tuple{Vararg{Int64}}}}\n\nState ψ contains multiple waveguides.\n\nWaveguide indeces provided as tuple or vector of length 2, means viewing viewing the state int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle with i = WI[1] and j = WI[2].\n\nIndex should follow syntax highlighted in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, Int64, Int64, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis, QuantumInterface.SpinBasis}}}, Np, Nw})), I<:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,WI1::Int,WI2::Int,index::I)  where {T<:MultipleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\n\nState ψ contains multiple waveguides.\n\nTwo waveguide indeces means viewing viewing the state int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle with i = WI1 and j = WI2.\n\nIndex should follow syntax highlighted in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, Int64, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis, QuantumInterface.SpinBasis}}}, Np, Nw})), I<:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,WI::Int,index::I)  where {T<:MultipleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\n\nState ψ contains multiple waveguides.\n\nOnly one waveguide index i=WI means viewing the state int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle.\n\nIndex should follow syntax highlighted in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T<:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis, QuantumInterface.SpinBasis}}}, Np})), I<:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,index::I) where {T <: SingleWaveguideKet,I<:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}\n\nState ψ only contains one waveguide. Index should follow syntax highlighted in view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis, QuantumInterface.SpinBasis}}}, Np, Nw})), I<:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,WI::I) where {T <: MultipleWaveguideKet,I<:Union{Vector{Int64},Tuple{Vararg{Int64}}}}\n\nState ψ contains multiple waveguides.\n\nWaveguide indeces provided as tuple or vector of length 2, means viewing viewing the state int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle with i = WI[1] and j = WI[2].\n\nNo index provided so groundstate is assumed. See view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis, QuantumInterface.SpinBasis}}}, Np, Nw}))","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,WI1::Int,WI2::Int) where {T <: MultipleWaveguideKet}\n\nState ψ contains multiple waveguides.\n\nTwo waveguide indeces means viewing viewing the state int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle with i = WI1 and j = WI2.\n\nNo index provided so groundstate is assumed. See view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoPhotonView-Union{Tuple{T}, Tuple{T, Int64}} where T<:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T<:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T<:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis, QuantumInterface.SpinBasis}}}, Np, Nw}))","page":"API","title":"WaveguideQED.TwoPhotonView","text":"TwoPhotonView(ψ::T,WI::Int) where {T <: MultipleWaveguideKet}\n\nState ψ contains multiple waveguides and waveguide index WI required. \n\nOnly one waveguide index i=WI means viewing the state int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle.\n\nNo index provided so groundstate is assumed. See view_waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.TwoWaveguideTimestepView","page":"API","title":"WaveguideQED.TwoWaveguideTimestepView","text":"TwoWaveguideTimestepView{T} <:AbstractVector{T}\n\nStructure for viewing slice along same times in twophoton states in two waveguides. Used in mul!. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.TwoWaveguideView","page":"API","title":"WaveguideQED.TwoWaveguideView","text":"TwoWaveguideView{T} <: AbstractMatrix{T}\n\nStructure for viewing state with one photon in waveguide i and j. Returned from TwoPhotonView. See also TwoPhotonView, twophoton, and view_waveguide\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideBasis","page":"API","title":"WaveguideQED.WaveguideBasis","text":"WaveguideBasis(Np,Nw, times)\nWaveguideBasis(Np, times)\n\nBasis for time binned Waveguide where Np is the number of photons in the waveguide and Nw the number of waveguides (default is 1). Currently number of photons is restricted to either 1 or 2. Times is timeinterval over which the photon state should be binned.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideCreate","page":"API","title":"WaveguideQED.WaveguideCreate","text":"WaveguideCreate{B1,B2,N,idx} <: WaveguideOperator{B1,B2}\n\nOperator structure for dispatching creation operation on Waveguide state. Np is used to dispatch one or two photon routine and idx denotes the index of the waveguide the operator is acting on. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideDestroy","page":"API","title":"WaveguideQED.WaveguideDestroy","text":"WaveguideDestroy{B1,B2,Np,idx} <: WaveguideOperator{B1,B2}\n\nOperator structure for dispatching annihilation operation on Waveguide state. Np is used to dispatch one or two photon routine and idx denotes the index of the waveguide the operator is acting on. \n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideOperator","page":"API","title":"WaveguideQED.WaveguideOperator","text":"Abstract class for WaveguideOperators. Used to dispatch special mul! function.\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideTransform","page":"API","title":"WaveguideQED.WaveguideTransform","text":"WaveguideTransform{B1,B2,Np,idx} <: WaveguideOperator{B1,B2}\n\nOperator structure for transforming an output state ketpsi_mathrmout = mathbfC kettildepsi_mathrmout Np is used to dispatch one or two photon routine and idx denotes the index of the waveguide the operator is acting on. See also effective_hamiltonian.\n\nExamples:\n\ntimes = 0:0.1:10\nbw = WaveguideBasis(1,2,times)\nC = 1/sqrt(2)*[1.0 -im;-im 1]\nC_transform = WaveguideTransform(bw,C)\npsi_tilde = ket(bw)\npsi = C_transform*psi_tilde\n\n\n\n\n\n","category":"type"},{"location":"API/#WaveguideQED.WaveguideTransformEvolution","page":"API","title":"WaveguideQED.WaveguideTransformEvolution","text":"WaveguideTransformEvolution{B1,B2,Np,idx} <: WaveguideOperator{B1,B2}\n\nOperator structure for transforming. Np is used to dispatch one or two photon routine and idx denotes the index of the waveguide the operator is acting on. \n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumInterface.dagger-Union{Tuple{WaveguideCreate{B, B, Np, idx}}, Tuple{idx}, Tuple{Np}, Tuple{B}} where {B, Np, idx}","page":"API","title":"QuantumInterface.dagger","text":"dagger(op::WaveguideCreate)\ndagger(op::WaveguideCreate)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.identityoperator-Tuple{CavityWaveguideOperator}","page":"API","title":"QuantumInterface.identityoperator","text":"identityoperator(a::CavityWaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.identityoperator-Tuple{NLevelWaveguideOperator}","page":"API","title":"QuantumInterface.identityoperator","text":"identityoperator(a::NLevelWaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.identityoperator-Tuple{WaveguideOperator}","page":"API","title":"QuantumInterface.identityoperator","text":"identityoperator(a::WaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor-Tuple{QuantumInterface.AbstractOperator, CavityWaveguideAbsorption}","page":"API","title":"QuantumInterface.tensor","text":"tensor(a::AbstractOperator,b::CavityWaveguideAbsorption)\ntensor(a::CavityWaveguideAbsorption,b::AbstractOperator)\ntensor(a::AbstractOperator,b::CavityWaveguideEmission)\ntensor(a::CavityWaveguideEmission,b::AbstractOperator)\n\nMethods for tensorproducts between QuantumOptics.jl operators and CavityWaveguideOperator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor-Tuple{QuantumInterface.AbstractOperator, NLevelWaveguideOperator}","page":"API","title":"QuantumInterface.tensor","text":"tensor(a::AbstractOperator, b::NLevelWaveguideOperator)\ntensor(a::NLevelWaveguideOperator, b::AbstractOperator)\n\nMethods for tensor products between QuantumOptics.jl operators and NLevelWaveguideOperator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor-Union{Tuple{T}, Tuple{F}, Tuple{BR}, Tuple{BL}, Tuple{T, QuantumOpticsBase.Operator{BL, BR, F}}} where {BL<:QuantumInterface.NLevelBasis, BR<:QuantumInterface.NLevelBasis, F, T<:(QuantumOpticsBase.LazyTensor{B, B, F, V, T} where {B, F, V, T<:Tuple{Union{WaveguideCreate, WaveguideDestroy}}})}","page":"API","title":"QuantumInterface.tensor","text":"tensor(a::WaveguideOperatorT, b::Operator{BL,BR,F}) where {BL<:NLevelBasis,BR<:NLevelBasis,F}\ntensor(a::Operator{BL,BR,F}, b::WaveguideOperatorT) where {BL<:NLevelBasis,BR<:NLevelBasis,F}\ntensor(a::WaveguideOperator, b::Operator{BL,BR,F}) where {BL<:NLevelBasis,BR<:NLevelBasis,F}\ntensor(a::Operator{BL,BR,F}, b::WaveguideOperator) where {BL<:NLevelBasis,BR<:NLevelBasis,F}\n\nSpecialized tensor product methods for N-level basis operators.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.create-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np","page":"API","title":"QuantumOpticsBase.create","text":"create(basis::WaveguideBasis{Np,1}) where {Np}\ncreate(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}\n\nCreation operator w^dagger for WaveguideBasis w_i(t_k)^dagger  emptyset rangle =  1_k emptyset rangle_i with cutoff (maximum number of photons Np) where i is the index of the waveguide. t_k is determined by the timeindex property of the operator which can be changed by set_waveguidetimeindex!(a::WaveguideOperator,k::Int) \n\nArguments\n\nbasis of type WaveguideBasis, defines cutoff photon number Np and number of waveguides Nw\ni determines which waveguide the operator acts on and should be i ≤ Nw. If Nw=1 then i=1 is assumed (there is only one waveguide).\n\nReturns\n\nWaveguideCreate\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumOpticsBase.destroy-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy(basis::WaveguideBasis{Np,1}) where {Np}\ndestroy(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}\n\nAnnihilation operator w for WaveguideBasis w_i(t_k)  1_j emptyset rangle_i = delta_kj  emptyset rangle with cutoff (maximum number of photons Np) where i is the index of the waveguide. t_k is determined by the timeindex property of the operator which can be changed by set_waveguidetimeindex!(a::WaveguideOperator,k::Int) \n\nArguments\n\nbasis of type WaveguideBasis, defines cutoff photon number Np and number of waveguides Nw\ni determines which waveguide the operator acts on and should be i ≤ Nw. If Nw=1 then i=1 is assumed (there is only one waveguide).\n\nReturns\n\nWaveguideDestroy\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.absorption-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}","page":"API","title":"WaveguideQED.absorption","text":"absorption(b1::WaveguideBasis{T},b2::FockBasis) where T\nabsorption(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideAbsorption that applies create(b::FockBasis) on FockBasis and destroy(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.detect_double_click-Union{Tuple{B}, Tuple{Any, Detector{B}, Detector{B}, Any}} where B","page":"API","title":"WaveguideQED.detect_double_click","text":"detect_double_click(ψ,detector1,detector2,projection)\ndetect_double_click(ψ,detector1,detector2)\n\nCalculate probability of observing projection after beamsplitter operation and two subsequent detection events defined in detector1 and detector2 on the state ψ.\n\nArguments\n\nψ can be either LazyTensorKet or LazySumKet and is the state on which the beamsplitter and detection is applied\ndetector1 defines the first beamsplitter and subsequent detection operation. See Detector for more details on how to define.\ndetector2 defines the second beamsplitter and subsequent detection operation. See Detector for more details on how to define.\nprojection if given is a LazyTensorKet or LazySumKet which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using get_all_projectors.\n\nReturns\n\nIf projection is given: Returns probability of having detector1 and detector2 click and being in state defined by projection\nIf projection is not given: Returns the total probability of having detector1 and detector2 click by applying all possibile projections with zerophotons in the waveguide using get_all_projectors.\n\nSee Beamsplitter for an example on how to use. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.detect_single_click-Tuple{Any, Detector, Any}","page":"API","title":"WaveguideQED.detect_single_click","text":"detect_single_click(ψ,detector::Detector,projection)\ndetect_single_click(ψ,detector::Detector)\n\nCalculate probability of observing projection after beamsplitter operation and subsequent detection event defined in detector on the state ψ.\n\nArguments\n\nψ can be either LazyTensorKet or LazySumKet and is the state on which the beamsplitter and detection is applied\ndetector defines the beamsplitter and subsequent detection operation. See Detector for more details on how to define.\nprojection if given is a LazyTensorKet or LazySumKet which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using get_all_projectors.\n\nReturns\n\nIf projection is given returns probability of having detector click and being in state defined by projection\nIf projection is not given returns the total probability of having a the detector click (only a single click, for double clicks use detect_double_click) by applying all possibile projections with zerophotons in the waveguide using get_all_projectors.\n\nSee Beamsplitter for an example on how to use.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.effective_hamiltonian-Union{Tuple{Nw}, Tuple{Np}, Tuple{WaveguideBasis{Np, Nw}, Any, Any, Any}} where {Np, Nw}","page":"API","title":"WaveguideQED.effective_hamiltonian","text":"effective_hamiltonian(bw::WaveguideBasis{Np,Nw},bs,C,G) where {Np,Nw}\n\nReturn the effective Hamiltonian for a waveguide system with basis bw coupled to a local emitter/cavity with the basis bc. C and G here determine the input output relations of the coupling such that: fracdd t a=-ilefta H_mathrmcright-Sigma a+mathbfk^T mathbfW_mathrmin, and mathbfW_text out (t)=mathbfC mathbfW_mathrmin(t)+a(t)mathbfd.  Here tildemathbfd =  tildemathbfk = -i left(left(mathbfI+fraci2 mathbfVright)^-1 right) mathbfGamma, where mathbfGamma is determined by the vector G with a length equal to the number of waveguide in bw. mathbfC is here given by C which is of dimensions (nw,nw) with nw being the number of waveguides in bw.\n\nThe resulting state kettildepsi_mathrmout from simulating with this Hamiltonian needs to be transformed using WaveguideTransform such that ketpsi_mathrmout = mathbfC kettildepsi_mathrmout to get the correct input-output relations.\n\nExamples:\n\ntimes = 0:0.1:10\ndt = times[2] - times[1]\n\nbw = WaveguideBasis(1,2,times)\nbe = FockBasis(1)\n\n\nC = [0 -1.0im; -1.0im 0]\nγ=1\nG = [sqrt(γ/dt),sqrt(γ/dt)]\n\nH = effective_hamiltonian(bw,be,C,G)\n\nξfun(t1,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t1-t0)^2/σ^2)\n\nψ_in = onephoton(bw,1,ξfun,1,5) ⊗ fockstate(be,0)\nψ_out_tilde = waveguide_evolution(times,ψ_in,H)\n\n\nC_transform = WaveguideTransform(bw,C) ⊗ identityoperator(be)\nψ_out = C_transform*ψ_out_tilde\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.emission-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}","page":"API","title":"WaveguideQED.emission","text":"emission(b1::WaveguideBasis{T},b2::FockBasis) where T\nemission(b1::FockBasis,b2::WaveguideBasis{T}) where T\n\nCreate CavityWaveguideEmission that applies destroy(b::FockBasis) on FockBasis and create(b::WaveguideBasis{T}) on WaveguideBasis{T}.  \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.expect_waveguide-Tuple{Any, Any, Any}","page":"API","title":"WaveguideQED.expect_waveguide","text":"expect_waveguide(O, psi,buffer)\n\nReturns the sum of expectation values of O over waveguide time indeces. This is usefull to extract information from waveguide states. For example the number of photons can be computed as: expect_waveguide(create(bw)*destroy(bw), psi, times), where BW is the waveguidebasis. Mathematically this is equivalent to sum_n langle psi  O(t_n)  psi rangle. For O(t_k) = w_k^dagger w_k acting on a single photon state psi rangle = sum_k xi(t_k) w_k^dagger 0rangle, one would therefore have: langle O rangle = sum_k xi(t_k)^2 = 1, where the last follows from xi(t) being normalized.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.expect_waveguide-Tuple{Any, Any}","page":"API","title":"WaveguideQED.expect_waveguide","text":"expect_waveguide(O, psi)\n\nReturns the sum of expectation values of O over waveguide time indeces. This is usefull to extract information from waveguide states. For example the number of photons can be computed as: expect_waveguide(create(bw)*destroy(bw), psi, times), where BW is the waveguidebasis. Mathematically this is equivalent to sum_n langle psi  O(t_n)  psi rangle. For O(t_k) = w_k^dagger w_k acting on a single photon state psi rangle = sum_k xi(t_k) w_k^dagger 0rangle, one would therefore have: langle O rangle = sum_k xi(t_k)^2 = 1, where the last follows from xi(t) being normalized.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.fast_unitary-Tuple{Any, Any, Any}","page":"API","title":"WaveguideQED.fast_unitary","text":"fast_unitary(times_eval,psi,H;order=2,fout=nothing)\n\nSee documentation for waveguide_evolution on how to define fout. J should be a list of collapse operators following documentation of timeevolution.mcwf_dynamic. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.fftket-Tuple{QuantumOpticsBase.Ket, Any}","page":"API","title":"WaveguideQED.fftket","text":"fftket(psi::Ket,idx)\n\nReturn the FFT xi(omega) of a onephoton wavefunction xi(t). Idx determines which waveguide.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}","page":"API","title":"WaveguideQED.get_all_projectors","text":"get_all_projectors(b)\n\nReturns all combinations of possible states with zerophotons in the waveguide. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_dt-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.get_dt","text":"get_dt(basis::WaveguideBasis)\nget_dt(basis::Basis)\nget_dt(basis::CompositeBasis)\n\nReturn nsteps of WaveguideBasis given either a WaveguideBasis or a CompositeBasis containing a WaveguideBasis\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_nsteps-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.get_nsteps","text":"get_nsteps(basis::WaveguideBasis)\nget_nsteps(basis::Basis)\nget_nsteps(basis::CompositeBasis)\n\nReturn nsteps of WaveguideBasis given either a WaveguideBasis or a CompositeBasis containing a WaveguideBasis\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_number_of_waveguides-Union{Tuple{WaveguideBasis{Np, Nw}}, Tuple{Nw}, Tuple{Np}} where {Np, Nw}","page":"API","title":"WaveguideQED.get_number_of_waveguides","text":"get_number_of_waveguides(basis::WaveguideBasis)\nget_number_of_waveguides(basis::Basis)\nget_number_of_waveguides(basis::CompositeBasis)\n\nReturn number of waveguides Nw of WaveguideBasis{Np,Nw} given either a WaveguideBasis{Np,Nw} or a CompositeBasis containing a WaveguideBasis{Np,Nw}\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguide_basis-Tuple{QuantumInterface.CompositeBasis}","page":"API","title":"WaveguideQED.get_waveguide_basis","text":"get_waveguide_basis(basis::CompositeBasis)\n\nReturns WaveguideBasis from CompositeBasis.bases\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguide_location-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.get_waveguide_location","text":"get_waveguide_location(basis::WaveguideBasis)\nget_waveguide_location(basis::CompositeBasis)\n\nReturn index of WaveguideBasis location in Hilbert space of basis b. Btotal = waveguidebasis ⊗ otherbasis where waveguidebasis is a WaveguideBasis and otherbasis some other basis then get_waveguide_location(Btotal) returns 1.  While Btotal = otherbasis ⊗ waveguidebasis with get_waveguide_location(Btotal) returns 2.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguide_operators-Tuple{QuantumOpticsBase.LazySum}","page":"API","title":"WaveguideQED.get_waveguide_operators","text":"get_waveguide_operators(basis::LazySum)\nget_waveguide_operators(basis::LazyProduct)\nget_waveguide_operators(basis::LazyTensor)\nget_waveguide_operators(basis::Tuple)\nget_waveguide_operators(basis::Array)\nget_waveguide_operators(basis::WaveguideOperator)\n\nReturns all WaveguideOperator in LazyOperator or from a list of operators. If no WaveguideOperator is found, and empty array is returned.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.get_waveguidetimeindex-Tuple{Any}","page":"API","title":"WaveguideQED.get_waveguidetimeindex","text":"get_waveguidetimeindex(op)\n\nReturn timeindex of operator or list of operators containing WaveguideOperator and assert that all timeindeces are the same. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.onephoton","page":"API","title":"WaveguideQED.onephoton","text":"Create a onephoton wavepacket in waveguide of the form W^dagger(xi) 0 rangle = int_t_0^t_end dt  xi(t) w_mathrmi^dagger(t) emptyset rangle = sum_k where i is the index of the waveguide and return it as a Ket. See also WaveguideBasis and OnePhotonView for how to view the state. \n\nExamples\n\ndt = 1\ntimes = 1:dt:10;\nbw = WaveguideBasis(1,times);\nψ = onephoton(bw,x->dt,norm=false);\nOnePhotonView(ψ) == ones(length(times))\n\nvec = collect(1:1:10);\nψ = onephoton(bw,vec);\nOnePhotonView(ψ) == vec\n\nbw = WaveguideBasis(1,3,times);\nψ = onephoton(bw,2,x->dt);\nOnePhotonView(ψ,2) == ones(length(times))\n\n\n\n\n\n","category":"function"},{"location":"API/#WaveguideQED.onephoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, AbstractArray}} where {T, Nw}","page":"API","title":"WaveguideQED.onephoton","text":"onephoton(b::WaveguideBasis{T,Nw},i,ξvec;norm=false) where {T,Nw}\n\nSince b contains a Nw waveguides, the index of the waveguide needed.\ni is the index of the waveguide at which the onephoton wavepacket is created in\nξ should be AbstractArray with length(ξ) == b.nsteps\nnorm::Bool=false: If true normalize the resulting wavepacket.    \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.onephoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Function, Vararg{Any}}} where {T, Nw}","page":"API","title":"WaveguideQED.onephoton","text":"onephoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Function,args...; norm=false) where {T,Nw}\n\nSince b contains Nw waveguides, the index of the waveguide needed.\ni is the index of the waveguide at which the onephoton wavepacket is created in\nξ should be broadcastable as ξ.(times,args...), where times  = 0:b.dt:(b.nsteps-1)*b.dt (the times used to define the waveguidebasis)\nargs...: additional arguments to be passed to ξ if it is a function.\nnorm::Bool=false: If true normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.onephoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, AbstractArray}} where T","page":"API","title":"WaveguideQED.onephoton","text":"onephoton(b::WaveguideBasis{T,1},ξ::AbstractArray;norm=false) where {T}\n\nSince b only contains a single waveguide, the index of the waveguide is not needed. \nξ should be AbstractArray with length(ξ) == b.nsteps \nnorm::Bool=false: If true normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.onephoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Vararg{Any}}} where T","page":"API","title":"WaveguideQED.onephoton","text":"onephoton(b::WaveguideBasis{T,1},ξ::Function,args...,norm=false) where {T}\n\nSince b only contains a single waveguide, the index of the waveguide is not needed. \nξ should be broadcastable as ξ.(times,args...), where times  = 0:b.dt:(b.nsteps-1)*b.dt (the times used to define the waveguidebasis)\nargs...: additional arguments to be passed to ξ if it is a function.\nnorm::Bool=false: If true normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.plot_twophoton!-Tuple{Any, TwoPhotonView, Any}","page":"API","title":"WaveguideQED.plot_twophoton!","text":"plot_twophoton!(ax,twophotonstate::TwophotonView,times;kwargs...)\nplot_twophoton!(ax,twophotonstate::TwoWaveguideView,times;kwargs...)\nplot_twophoton!(ax,state::Ket,times;kwargs...)\nplot_twophoton!(ax,twophotonstate,times;kwargs...)\n\nPlots the twophoton state in the given ax. \n\nArguments\n\nax of type PyObject <AxesSubplot: > from PyPlot\nState to be plotted twophotonstate or state. If state is a Ket TwoPhotonView is called to extract twophotonstate. Otherwise twophotonstate should be AbstractArray of dimensions (length(times),length(times)).\n\n#Return ax.contour object with the plotted state.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T<:WaveguideOperator","page":"API","title":"WaveguideQED.set_waveguidetimeindex!","text":"set_waveguidetimeindex!(op,index)\n\nSet timeindex of all WaveguideOperator in operator or list of operators to index\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton","page":"API","title":"WaveguideQED.twophoton","text":"Create a twophoton wavepacket of the form int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle where i and j are the indeces of the waveguide and return it as a Ket.\n\nSee also WaveguideBasis and TwoPhotonView for how to view the state. \n\n#Examples  Creating twophoton state with only one waveguide (using a function):\n\nusing LinearAlgebra; #hide\ntimes = 1:1:10;\nbw = WaveguideBasis(2,times);\nψ = twophoton(bw,(t1,t2)->1,norm=false);\nψview = TwoPhotonView(ψ);\nψview == ones((length(times),length(times)))\n\nψ = twophoton(bw,(t1,t2,arg1)->arg1,123,norm=false);\nψview = TwoPhotonView(ψ);\nψview == 123*ones((length(times),length(times)))\n\n\nCreating twophoton state with only one waveguide (using a matrix):\n\nψ = twophoton(bw,ones((length(times),length(times))),norm=false);\nψview = TwoPhotonView(ψ);\nψview == ones((length(times),length(times)))\n\nCreating twophoton state in waveguide 2 with multiple waveguides\n\nbw = WaveguideBasis(2,3,times)\nψ = twophoton(bw,2,(t1,t2)->1,norm=false);\n\nCreating twophoton state across waveguide 1 and 2\n\nbw = WaveguideBasis(2,3,times)\nψ = twophoton(bw,1,2,(t1,t2)->1,norm=false);\n\n\n\n\n\n","category":"function"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{I}, Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, I, Function, Any, Vararg{Any}}} where {T, Nw, I<:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,Nw},idx::I,ξ::Function,times,args...;norm=false) where {T,Nw,I<:Union{Vector{Int64},Tuple{Vararg{Int64}}}} = twophoton(b,idx[1],idx[2],ξ,times,args...,norm=norm)\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains multiple waveguides and index i is need.\nI[1] denotes the index i of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nI[2] denotes the index j of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nξ given as a function should follow  ξ(times[l],times[m],args...).\ntimes: A vector or range of length(times) = b.nsteps.\nargs...: additional arguments to be passed to ξ.\nnorm::Bool=false: Toggles whether to normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{I}, Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, I, Matrix}} where {T, Nw, I<:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,Nw},idx::I,ξ::Matrix;norm=false) where {T,Nw,I<:Union{Vector{Int64},Tuple{Vararg{Int64}}}}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains multiple waveguides and index i is need.\nI[1] denotes the index i of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nI[2] denotes the index j of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nξ given as a matrix of dimension (b.nsteps, b.nsteps).\nnorm::Bool=false: Toggles whether to normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Function, Vararg{Any}}} where {T, Nw}","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Function,args...;norm=false) where {T,Nw}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains multiple waveguides and index i is need.\ni denotes the index of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle.\nξ given as a function should follow  ξ(t1,t2,args...) where t1 and t2 are the input times.\nargs...: additional arguments to be passed to ξ.\nnorm::Bool=false: Toggles whether to normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Int64, Function, Vararg{Any}}} where {T, Nw}","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,Nw},i::Int,j::Int,ξ::Function,args...;norm=false) where {T,Nw}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains multiple waveguides and index i is need.\ni denotes the index of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nj denotes the index of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nξ given as a function should follow  ξ(t1,t2,args...) where t1 and t2 are the input times.\nargs...: additional arguments to be passed to ξ.\nnorm::Bool=false: Toggles whether to normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Int64, Matrix}} where {T, Nw}","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,Nw},i::Int,j::Int,ξ::Matrix;norm=false) where {T,Nw}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains multiple waveguides and index i is need.\ni denotes the index of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nj denotes the index of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmj^dagger(t) emptyset rangle.\nξ given as a matrix of dimension (b.nsteps, b.nsteps).\nnorm::Bool=false: Toggles whether to normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Matrix}} where {T, Nw}","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Matrix;norm=false) where {T,Nw}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains multiple waveguides and index i is need.\ni denotes the index of the waveguide in the twophoton state: int_t_0^t_end dt int_t_0^t_end dt  xi(tt) w_mathrmi^dagger(t)w_mathrmi^dagger(t) emptyset rangle.\nξ given as a matrix of dimension (b.nsteps, b.nsteps).\nnorm::Bool=false: Toggles whether to normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Vararg{Any}}} where T","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,1},ξ::Function,args...,norm=false) where {T}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains only one waveguide and no index needed.\nξ given as a function should follow  ξ(t1,t2,args...),  where t1 and t2 are the input times.\nargs...: additional arguments to be passed to ξ if it is a function.\nnorm::Bool=false: Toggles whether to normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.twophoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Matrix}} where T","page":"API","title":"WaveguideQED.twophoton","text":"twophoton(b::WaveguideBasis{T,1},ξ::Matrix;norm=false) where {T}\n\nArguments\n\nb::WaveguideBasis{T,Nw} contains only one waveguide and no index needed.\nξ given as a matrix of dimension (b.nsteps, b.nsteps).\nnorm::Bool=false: Toggles whether to normalize the resulting wavepacket.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}","page":"API","title":"WaveguideQED.view_waveguide","text":"view_waveguide(ψ::ket)\nview_waveguide(ψ::ket,index)\n\nView the Waveguide state given a state ψ containing a WaveguideBasis by returning view(reshape(ψ.data,Tuple(ψ.basis.shape)),index...). If no index is provided the ground state is returned. The index provided should be of the form [:,i,j] where (:) is at the location of the WaveguideBasis and i and j are indeces of other basises. See example: \n\nusing QuantumOptics;\ntimes=0:1:10;\nbw = WaveguideBasis(1,times);\nbc = FockBasis(2);\nψ_waveguide = Ket(bw,ones(length(times)));\nψ_total = ψ_waveguide ⊗ fockstate(bc,0) ⊗ fockstate(bc,0);\nψ_view = view_waveguide(ψ_total);\nψ_view_index = view_waveguide(ψ_total,[:,1,1]);\nψ_view==ψ_view_index\n\nψ_total = ψ_waveguide ⊗ fockstate(bc,2) ⊗ fockstate(bc,1);\nview_waveguide(ψ_total,[:,3,2]) == ones(length(times))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.waveguide_evolution-Tuple{Any, Any, Any}","page":"API","title":"WaveguideQED.waveguide_evolution","text":"waveguide_evolution(tspan, psi0, H; fout)\n\nIntegrate time-dependent Schroedinger equation to evolve states or compute propagators.\n\nArguments\n\ntspan: Vector specifying the points of time for which output should be displayed.\npsi0: Initial state vector can only be a ket.\nH: Operator containing a WaveguideOperator either through a LazySum or LazyTensor.\nfout=nothing: If given, this function fout(t, psi) is called every time step. Example: fout(t,psi) = expect(A,psi) will return the epectation value of A at everytimestep.  If fout =1 the state psi is returned for all timesteps in a vector.  ATTENTION: The state psi is neither normalized nor permanent! It is still in use by the ode solver and therefore must not be changed.\n\nReturns\n\nif fout=nothing the output of the solver will be the state ψ at the last timestep. \nif fout is given a tuple with the state ψ at the last timestep and the output of fout is given. If fout returns a tuple the tuple will be flattened.\nif fout = 1 ψ at all timesteps is returned.\n\nExamples\n\nfout(t,psi) = (expect(A,psi),expect(B,psi)) will result in  a tuple (ψ, ⟨A(t)⟩,⟨B(t)⟩), where ⟨A(t)⟩ is a vector with the expectation value of A as a function of time.\n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.waveguide_montecarlo-NTuple{4, Any}","page":"API","title":"WaveguideQED.waveguide_montecarlo","text":"waveguide_montecarlo(times,psi,H,J;fout=nothing)\n\nSee documentation for waveguide_evolution on how to define fout. J should be a list of collapse operators following documentation of timeevolution.mcwf_dynamic. \n\n\n\n\n\n","category":"method"},{"location":"API/#WaveguideQED.zerophoton-Tuple{WaveguideBasis}","page":"API","title":"WaveguideQED.zerophoton","text":"zerophoton(bw::WaveguideBasis)\n\nCreate a waveguide vacuum state  emptyset  angle\n\n\n\n\n\n","category":"method"},{"location":"API/#LinearAlgebra.mul!","page":"API","title":"LinearAlgebra.mul!","text":"mul!(result::Ket{B1}, a::LazyTensor{B1,B2,F,I,T}, b::Ket{B2}, alpha, beta)\n\nIn-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a LazyTensor that contains a WaveguideOperator \n\n\n\n\n\nmul!(result::Ket{B1}, a::CavityWaveguideEmission, b::Ket{B2}, alpha, beta) where {B1<:Basis,B2<:Basis}\nmul!(result::Ket{B1}, a::CavityWaveguideAbsorption, b::Ket{B2}, alpha, beta) where {B1<:Basis,B2<:Basis}\n\nFast in-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a CavityWaveguideOperator.\n\n\n\n\n\nmul!(result::Ket{B1}, a::NLevelWaveguideOperator, b::Ket{B2}, alpha, beta) where {B1<:Basis,B2<:Basis}\n\nFast in-place multiplication of operators/state vectors. Updates result as result = alpha*a*b + beta*result. a is a NLevelWaveguideOperator.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumOpticsBase.create","page":"API","title":"QuantumOpticsBase.create","text":"create(basis::WaveguideBasis{Np,1}) where {Np}\ncreate(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}\n\nCreation operator w^dagger for WaveguideBasis w_i(t_k)^dagger  emptyset rangle =  1_k emptyset rangle_i with cutoff (maximum number of photons Np) where i is the index of the waveguide. t_k is determined by the timeindex property of the operator which can be changed by set_waveguidetimeindex!(a::WaveguideOperator,k::Int) \n\nArguments\n\nbasis of type WaveguideBasis, defines cutoff photon number Np and number of waveguides Nw\ni determines which waveguide the operator acts on and should be i ≤ Nw. If Nw=1 then i=1 is assumed (there is only one waveguide).\n\nReturns\n\nWaveguideCreate\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumOpticsBase.destroy","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy(basis::WaveguideBasis{Np,1}) where {Np}\ndestroy(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}\n\nAnnihilation operator w for WaveguideBasis w_i(t_k)  1_j emptyset rangle_i = delta_kj  emptyset rangle with cutoff (maximum number of photons Np) where i is the index of the waveguide. t_k is determined by the timeindex property of the operator which can be changed by set_waveguidetimeindex!(a::WaveguideOperator,k::Int) \n\nArguments\n\nbasis of type WaveguideBasis, defines cutoff photon number Np and number of waveguides Nw\ni determines which waveguide the operator acts on and should be i ≤ Nw. If Nw=1 then i=1 is assumed (there is only one waveguide).\n\nReturns\n\nWaveguideDestroy\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumInterface.dagger","page":"API","title":"QuantumInterface.dagger","text":"dagger(op::WaveguideCreate)\ndagger(op::WaveguideCreate)\n\nDagger opration on Waveguide operator. \n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumInterface.tensor","page":"API","title":"QuantumInterface.tensor","text":"tensor(a::AbstractOperator,b::CavityWaveguideAbsorption)\ntensor(a::CavityWaveguideAbsorption,b::AbstractOperator)\ntensor(a::AbstractOperator,b::CavityWaveguideEmission)\ntensor(a::CavityWaveguideEmission,b::AbstractOperator)\n\nMethods for tensorproducts between QuantumOptics.jl operators and CavityWaveguideOperator.\n\n\n\n\n\ntensor(a::AbstractOperator, b::NLevelWaveguideOperator)\ntensor(a::NLevelWaveguideOperator, b::AbstractOperator)\n\nMethods for tensor products between QuantumOptics.jl operators and NLevelWaveguideOperator.\n\n\n\n\n\ntensor(a::WaveguideOperatorT, b::Operator{BL,BR,F}) where {BL<:NLevelBasis,BR<:NLevelBasis,F}\ntensor(a::Operator{BL,BR,F}, b::WaveguideOperatorT) where {BL<:NLevelBasis,BR<:NLevelBasis,F}\ntensor(a::WaveguideOperator, b::Operator{BL,BR,F}) where {BL<:NLevelBasis,BR<:NLevelBasis,F}\ntensor(a::Operator{BL,BR,F}, b::WaveguideOperator) where {BL<:NLevelBasis,BR<:NLevelBasis,F}\n\nSpecialized tensor product methods for N-level basis operators.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumInterface.identityoperator","page":"API","title":"QuantumInterface.identityoperator","text":"identityoperator(a::WaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\nidentityoperator(a::CavityWaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\nidentityoperator(a::NLevelWaveguideOperator)\n\nReturn identityoperator(a.basis_l).\n\n\n\n\n\n","category":"function"},{"location":"theoreticalbackground/#theory","page":"Theoretical Background","title":"Theoretical Background","text":"","category":"section"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"In this section, we go over the necessary theory to work with continuous fockstates in the WaveguideQED.jl","category":"page"},{"location":"theoreticalbackground/#Continuous-Fock-States","page":"Theoretical Background","title":"Continuous Fock States","text":"","category":"section"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The single photon continuous fock state can be defined as:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginequation*\n    ketpsi = W^dagger(xi) ket0 = int_t_0^t_end mathrmdt  xi(t) w^dagger(t) ketemptyset\nendequation*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"here W^dagger(xi) creates a photon with the wavefunction xi(t). w^dagger(t) is the creation operator for a photon at time t, and it obeys the commutation relation: leftw(t)w(t)right  = delta(t-t). The probability of observing a photon at time t is given by: brapsi w^dagger(t) w(t) ketpsi = xi^(1)(t)^2. The interpretation of the wavefunction xi^(1)(t). The wavefunction xi(t) thus describes the temporal distribution of the photon.","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The heart of the photon time-binning is discretizing the continuous fock state into time-bins of width Delta t. The interaction with the emitter/cavity is then assumed to span only one time-bin at a time, corresponding to a spectrally flat interaction between the waveguide and emitter/cavity. We thus discretize the annihilation and creation operators by taking[1]:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginequation*\n    w(t_k) = w(k Delta t) rightarrow  fracw_ksqrtDelta t     textwith  left w_j w_k^dagger right  = delta_jk\nendequation*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"where w_k is the descritized operator and the factor of 1sqrtDelta t assures the commutator relation in the limit of Delta t rightarrow 0. We denote the action of the discretized creation operator as: w_k^dagger ketemptyset = ket1_k meaning a single photon in time-bin k. This means that the single photon continuous fock state becomes:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginequation*\n    ketpsi = int_t_0^t_end mathrmdt  xi(t) w^dagger(t) ketemptyset rightarrow \nsum_k=1^N sqrtDelta t xi(t_k) w_k^dagger ketemptyset\nendequation*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"In WaveguideQED.jl, the time-bins above are represented as elements in arrays corresponding to each time-bin:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: Alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Let`s say you want to represent a single photon continuous fock state that starts at t=0 and ends at t=10 with Delta t = 01. This can be done by creating a waveguide basis defined on such a time interval:a","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"using WaveguideQED\ntimes = 0:0.1:10\nbw = WaveguideBasis(1,times)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Notice that the input for WaveguideBasis is 1 and times. 1 denotes the maximum excitation number of fockstates (currently can only be 1 or 2), and times the is the time interval over which the continuous fockstate is defined. To define the continuous fockstate, we need to define a wavefunction xi. In the following, we define a Gaussian wavefunction located around t=5 with a width of sigma = 1:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nσ,t0 = 1,5\nψ = onephoton(bw,ξ,σ,t0)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"This state can be visualized by:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"using PyPlot\nrcParams = PyPlot.PyDict(PyPlot.matplotlib.\"rcParams\") #hide\nrcParams[\"font.size\"] = 20 #hide\nrcParams[\"font.family\"] = \"serif\" #hide\nrcParams[\"mathtext.fontset\"] =\"cm\" #hide\nviewed_state = OnePhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,real.(viewed_state),\"r-\")\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(L\"$\\xi(t)$\")\nplt.tight_layout() #hide\nplt.savefig(\"one_continuous_fockstate.svg\") #hide\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The time-binned creation and annihilation operators are easily created from the basis:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"w = destroy(bw)\nwd = create(bw)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The time-bin that the operator acts on is set by either:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"w.timeindex = 10\nwd.timeindex = 10\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"or:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"set_waveguidetimeindex!(w,10)\nset_waveguidetimeindex!(wd,10)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The effect of the creation operator is to create a photon in timebin k and can be illustrated as:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: Alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"This is also seen if we plot the creation operator acting on the vacuum:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"ψ = wd*zerophoton(bw)\nviewed_state = OnePhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,real.(viewed_state),\"r-\");\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(L\"$\\xi(t)$\")\nplt.tight_layout()\nplt.savefig(\"created_onephoton_continuous_fockstate.svg\") #hide\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"We see a spike around t = times[10] = 0.9, where we now created an excitation. In itself, the waveguide basis, states, and operators are not particularly interesting, but when combined with other quantum mechanical systems such as cavities and emitters, the framework can produce powerful results. See Combining with QuantumOptics for an introduction on how to combine with quantum systems defined in 'QuantumOptics.jl'.","category":"page"},{"location":"theoreticalbackground/#Continuous-two-photon-fock-states","page":"Theoretical Background","title":"Continuous two-photon fock states","text":"","category":"section"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"So far, we have considered only one excitation in the waveguide. We can extend the definition of a one-photon continuous fock state to a two-photon state as[2]:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginalign*\nfrac1sqrt2leftW^dagger(xi)right^20rangle = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi(t) xileft(t^primeright) w^dagger(t) w^daggerleft(t^primeright)0rangle \n = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi^(2)(tt) w^dagger(t) w^daggerleft(t^primeright)0rangle  \nendalign*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Here, we here defined the two photon wavefunction xi^(2)(tt) = xi(t) xileft(t^primeright). The state is now defined over two times, which describes the probability of observing photon A at time t and photon B at time t. In this case, the state is a product state xi^(2)(tt) = xi(t) xileft(t^primeright), and both probabilities are described by the (same) single photon wavefunction xi(t), but one could have entangled states across time. This means a non-seperable wavefunction xi^(2)(tt) neq xi_1(t)xi_2(t). For now, we will consider a symmetric and separable state.","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The time-binning is in a similar fashion defined as:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"beginalign*\nfrac1sqrt2leftW^dagger(xi)right^20rangle = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi(t) xileft(t^primeright) w^dagger(t) w^daggerleft(t^primeright)0rangle \n rightarrow frac1sqrt2 sum_i=1^N sum_k=1^N xileft(t_iright) xileft(t_kright) w^daggerleft(t_iright) w^daggerleft(t_kright)0rangle \n =frac1sqrt2 sum_i=1^N sum_k neq i^N xileft(t_iright) xileft(t_kright) w^daggerleft(t_iright) w^daggerleft(t_kright)0rangle+sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle \n =frac1sqrt2 sum_i=1^N sum_ki^N (xileft(t_iright) xileft(t_kright) + xileft(t_kright) xileft(t_iright)) left1_t_i 1_t_krightrangle+sum_i=1^N xileft(t_iright) xileft(t_iright)left2 t_irightrangle\nendalign*","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The sum is allowed to run over only half of the times due to the symmetry of the photons (it's equivalent to having one photon at time-bin k and then one photon at time-bin j or one photon at time-bin j and then one photon at time-bin k). This is how the two-photon state is saved in the underlying arrays and can be illustrated as:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Creating then is:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"We can define a two-photon basis and corresponding operator by:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"bw = WaveguideBasis(2,times)\nw = destroy(bw)\nwd = create(bw)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"The creation operator can then be visualized by acting on onephoton filled with ones. This is seen in the following. Note that the state is visualized as a contour plot mirrored around the diagonal.","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"set_waveguidetimeindex!(wd,50)\npsi_plot = wd*onephoton(bw,x->1)\nfig,ax = subplots(1,1,figsize=(4.5,4.5))\nplot_twophoton!(ax,psi_plot,times)\nplt.savefig(\"twophoton_created.svg\") #hide\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"If we want to create a two-photon Gaussian state, we instead do:","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nξ2(t1,t2,σ,t0) = ξ(t1,σ,t0)*ξ(t2,σ,t0)\nσ,t0 = 1,5\nψ = twophoton(bw,ξ2,σ,t0) / sqrt(2)\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"Here, we defined the two-photon equivalent of our single-photon Gaussian state. Note the factor of sqrt2 that is necessary for the state to be normalized. Alternatively, twophoton(bw,ξ2,σ,t0;norm=true) would return a normalized state. When we visualize it, we now need two times, and we make a contour plot. This is easily done by viewing the two-photon state and using plot_twophoton!: ","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"viewed_state = TwoPhotonView(ψ)\nfig,ax = subplots(1,1,figsize=(4.5,4.5))\nplot_twophoton!(ax,viewed_state,times)\nax.set_ylabel(\"time [1/γ]\")\nax.set_xlabel(\"time [1/γ]\") \nplt.tight_layout()\nplt.savefig(\"two_continuous_fockstate.svg\") #hide\nnothing #hide","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"(Image: alt text)","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"[1]: [1]","category":"page"},{"location":"theoreticalbackground/","page":"Theoretical Background","title":"Theoretical Background","text":"[2]: [2]","category":"page"},{"location":"beamsplitter/#Beamsplitter_docs","page":"Beamsplitters","title":"Beamsplitters","text":"","category":"section"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"Having introduced multiple waveguides in Multiple Waveguides, it is natural to implement the beamsplitter operation and consider some of the common measurements one would make on states having undergone a beamsplitter transformation.","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"We start by introducing how a beamsplitter can be implemented using two waveguides that interact. For simplicity, we consider only a single photon in one waveguide. First, we create the basis, operators of the multiple waveguides, and an initial single photon state with a gaussian wavefunction residing in waveguide 1:","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"using WaveguideQED #hide\nusing QuantumOptics #hide\ntimes = 0:0.1:10\ndt = times[2] - times[1]\nNPhotons = 2\nNWaveguides = 2\nbw = WaveguideBasis(NPhotons,NWaveguides,times)\nw1 = destroy(bw,1)\nwd1 = create(bw,1)\nw2 = destroy(bw,2)\nwd2 = create(bw,2)\n\n\nξ(t, t0=5, σ=1) = complex(√(2/σ)*(log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2))\npsi = onephoton(bw,1, ξ)\nnothing #hide","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"We now want to consider the following beamsplitter transformation: w_k1 rightarrow cos(V) w_k1 - i sin(V) w_k2 and equivalently for waveguide 2: w_k2 rightarrow - i sin(V) w_k1 + cos(V) w_k2. Having access to our initial Gaussian wavefunction, we could just create the transformed state as:","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"V = pi/4\npsi_trans_manual = cos(V) * onephoton(bw,1, ξ) -im*sin(V)*onephoton(bw,2, ξ) \nnothing #hide","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"A more automatic and equivalent method is, however, instead to let the waveguide state undergo evolution under the Hamiltonian: H = V( w_k1^dagger w_k2 + w_k2^dagger w_k1), which performs the same transformation. See Section 4.3 for details of the derivation. We can confirm this by:","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"using PyPlot\nrcParams = PyPlot.PyDict(PyPlot.matplotlib.\"rcParams\") #hide\nrcParams[\"font.size\"] = 20 #hide\nrcParams[\"font.family\"] = \"serif\" #hide\nrcParams[\"mathtext.fontset\"] =\"cm\" #hide\nVs = 0:pi/32:pi\nreflection = zeros(length(Vs))\ntransmission = zeros(length(Vs))\nn1 = wd1 *w1\nn2 = wd2 *w2\npsi = onephoton(bw,1, ξ)\nfor (i,V) in enumerate(Vs)\n H  = V/dt*(wd1 * w2 + wd2*w1)\n    \n psi_trans = waveguide_evolution(times,psi,H)\n\n transmission[i] = expect_waveguide(n1,psi_trans)\n reflection[i] = expect_waveguide(n2,psi_trans)\nend\nfig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(Vs/pi,reflection,\"b-\",label=\"Waveguide a\")\nax.plot(Vs/pi,transmission,\"r-\",label=\"Waveguide b\")\nax.set_xlabel(L\"V [$\\pi$]\")\nax.set_ylabel(\"Population\")\nplt.tight_layout()\nplt.savefig(\"beamsplitter_trans.svg\") #hide\nnothing #hide","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"(Image: beamsplitter)","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"Here, we see this population of waveguides 1 and 2 after the transformation varies as cosines and sines as we change the interaction parameter V. Thus, we confirm that we are applying the desired transformation. For an even beamsplitter, we thus choose V=pi4 ","category":"page"},{"location":"beamsplitter/#hom","page":"Beamsplitters","title":"Hong Ou Mandel with twophotons","text":"","category":"section"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"As a more advanced example, we now consider a Hong Ou Mandel setup, where we have one photon in each waveguide impinging on a beamsplitter. If the two photons equivalent, we will see the Hong Ou Mandel effect and thus expect no photons in both waveguide simultanouesly after the transformation. As a measure of this, we thus calculate the chance of having a coincidence count where one photon is in waveguide one while the other is in waveguide 2. This coincendence is calculated using the two projection operators:","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"P_1 = int_0^T dt w_1^dagger(t) 0ranglelangle0 w_1(t) qquad P_2 = int_0^T dt w_2^dagger(t) 0ranglelangle0 w_2(t)","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"where w_1(t) and w_2(t) are lowering operators for two waveguides. The chance of coincidence count is computed by langlepsiP_1 P_2 psirangle. ","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"To compute the coincidence count expectation, we create our own custom expectation value function:","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"n1 = wd1*w1\nn2 = wd2*w2\nexpval_op = n1*n2\nusing LinearAlgebra\nfunction expect_waveguide2(O,psi,times)\n psi_c = copy(psi)\n expval = 0\n  for i in eachindex(times)\n      set_waveguidetimeindex!(n1,i)\n      for j in eachindex(times)\n          set_waveguidetimeindex!(n2,j)\n          mul!(psi_c, O, psi)\n expval += dot(psi_c.data,psi.data)\n      end\n  end\n  return expval\nend\nnothing #hide","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"Here we evaluate w_1^dagger(t) w_1(t) at one timeidex i, while we evaluate w_2^dagger(t) w_2(t) at another timeidex j. Together, this gives us the total coincidence count chance. In the following, we use the Hamiltonian from the previous section with V=pi4 and consider two Gaussian photons in each their waveguide with different centers of time t_0. By changing the difference in t_0, we can see the transition from a perfect overlap, meaning no coincidence count, to no overlap, meaning that the two photons never interact. In this case, the two photons will split up randomly, and 14 of the time, they will end up in waveguide 1. Similarly, 14 of the time they will end up in waveguide 2, and the remaining 12 time they will end up in each of their waveguides. Thus, we expect a coincidence count of 12 when the two pulses are fully separated. Note that in the above function, we can just use the waveguide operators as projectors as we never have twophotons in both waveguides. ","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"taus = -3:0.1:3\nξ_twophoton(t1, t2, t01, t02) = ξ(t1, t01) * ξ(t2, t02)\nV = pi/4\nH  = V/dt*(wd1*w2 + wd2*w1)\ncoincidences = zeros(length(taus))\nt01 = 5\nfor (i, τ) in enumerate(taus)\n t02 = 5 + τ  \n psi_pre = twophoton(bw, [1,2], ξ_twophoton, t01,t02)\n ψ = waveguide_evolution(times,psi_pre,H)\n coincidences[i] = expect_waveguide2(expval_op, ψ,times)\nend\n\nfig, ax = subplots(1,1, figsize=(9,4.5))\nax.plot(taus, coincidences,\"r-\")\nax.set_xlabel(L\"Delay between pules $\\tau$\")\nax.set_ylabel(\"Coincedence chance\")\ntight_layout()\nsavefig(\"hom.svg\") #hide\nnothing #hide","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"(Image: hom_plot)","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"We could also have created this plot by performing the beamsplitter operation by hand and instead initializing the state directly in this state. The initial state we consider is a single photon in each waveguide: psi rangle = int int dt_1 dt_2 xi_1(t_1) xi_2(t_2) w_1^dagger(t_1) w_2^dagger(t_2) ketemptyset, where xi_1(t_1) and xi_2(t_2) denote the wavefunction of the photon in waveguide 1 and 2, respectively. Notice that there is no factor of 1sqrt2 in front of the initial state as the two photons occupy different waveguides. If they initially occupied the same waveguide, we would need a factor of 1sqrt2 for the state to be normalized. Performing the beamsplitter operation w_1(t) rightarrow 1sqrt2 ( w_1(t) - i w_2(t)) and w_2(t) rightarrow 1sqrt2 ( - i w_1(t) + w_2(t)), we arrive at the transformed state:","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"beginalign*\npsi rangle_BS = frac12left ( i int int dt_1 dt_2 xi_1(t_1) xi_2(t_2) w_1^dagger(t_1) w_1^dagger(t_2) ketemptyset - i int int dt_1 dt_2 xi_1(t_1) xi_2(t_2) w_2^dagger(t_1) w_2^dagger(t_2) ketemptyset right  \n + left  int int dt_1 dt_2 xi_1(t_1) xi_2(t_2) w_1^dagger(t_1) w_2^dagger(t_2)ketemptyset - int int dt_1 dt_2 xi_1(t_1) xi_2(t_2) w_2^dagger(t_1) w_1^dagger(t_2)ketemptyset right )\nendalign*","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"taus = -3:0.1:3\ncoincidences_manual = zeros(length(taus))\nt01 = 5\nfor (i, τ) in enumerate(taus)\n t02 = 5 + τ  \n psi_trans = 1/2*( im*twophoton(bw, 1, ξ_twophoton, t01,t02) - im * twophoton(bw, 2, ξ_twophoton, t01,t02)\n + twophoton(bw, [1,2], ξ_twophoton, t01,t02) - twophoton(bw, [2,1], ξ_twophoton, t01,t02))\n coincidences_manual[i] = expect_waveguide2(expval_op, psi_trans,times)\nend\n\nfig, ax = subplots(1,1, figsize=(9,4.5))\nax.plot(taus, coincidences,\"r-\",label=\"Hamiltonian transformation\")\nax.plot(taus, coincidences_manual,\"b--\",label=\"Manual transformation\")\nax.set_xlabel(L\"Delay between pules $\\tau$\")\nax.set_ylabel(\"Coincedence chance\")\nax.legend(fontsize=10)\ntight_layout()\nsavefig(\"hom2.svg\") #hide\nnothing #hide","category":"page"},{"location":"beamsplitter/","page":"Beamsplitters","title":"Beamsplitters","text":"(Image: hom_plot2)","category":"page"},{"location":"multiplewaveguides/#Multiple-waveguides","page":"Multiple waveguides","title":"Multiple waveguides","text":"","category":"section"},{"location":"multiplewaveguides/#twowaveguide","page":"Multiple waveguides","title":"Two Waveguides","text":"","category":"section"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"In the previous examples, we have only considered cases with a single waveguide. In this tutorial, we show how to model a beamsplitter and an optical switch using two waveguides. A beamsplitter or a swap gate can be modeled using the Hamiltonian H_I = V(w_1^dagger w_2 + w_2^dagger w_1) where V is some interaction strength that determines which interaction is modeled (we will discuss this in detail later). w_1 and w_2 are the annihilation operators of the two waveguides. A sketch of the system can be seen here:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"(Image: Alt text)","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"We can describe the state of two waveguides with a total of N excitations by adding an argument specifying the number of waveguides as:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"using WaveguideQED #hide\nusing QuantumOptics #hide\ntimes = 0:0.1:10\ndt = times[2] - times[1]\nNPhotons = 2\nNWaveguides = 2\nbw = WaveguideBasis(NPhotons,NWaveguides,times)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"When creating operators, we now have to specify which waveguide they are acting on (in this case, number one or two). This is done by an extra argument to create and destroy:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"wd1 = create(bw,1)\nw1 = destroy(bw,1)\nwd2 = create(bw,2) \nw2 = destroy(bw,2)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"Similarly, initializing one or two-photon states in the first or second waveguide is done by:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nξ2(t1,t2,σ,t0) = ξ(t1,σ,t0)*ξ(t2,σ,t0)\nψ_single_1 = onephoton(bw,1,ξ,2,5)\nψ_double_1 = twophoton(bw,1,ξ2,2,5)\nψ_single_2 = onephoton(bw,2,ξ,2,5)\nψ_double_2 = twophoton(bw,2,ξ2,2,5)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"If we want to describe a simultaneous excitation in both waveguides (states like ket1_i_mathrm1ket1_j _mathrm2 where the subscript $\\ket{1i}\\mathrm{i}$ means waveguide i) we specify both indices of the waveguides:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"ψ_single_1_and_2 = twophoton(bw,[1,2],ξ2,2,5)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/#Beamsplitter","page":"Multiple waveguides","title":"Beamsplitter","text":"","category":"section"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"Let's now treat the same example as in Interference on Beamsplitter. We consider the two waveguides in an identic single-photon state and thus use the above defined ψ_single_1_and_2. The Hamiltonian governing a beamsplitter in the time-binned formalism has V= pi4:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"V = pi/4\nH = im*V/dt*(wd2*w1 - wd1*w2)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"We can then evolve the system under this Hamiltonian to perform the beam-splitting operation:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"psi_out = waveguide_evolution(times,ψ_single_1_and_2,H)\n\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"We can then view the final state to verify that we only have two photons in the same waveguide simultaneously:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"psi_second = TwoPhotonView(psi_out,2);\npsi_first = TwoPhotonView(psi_out,1);\npsi_first_second = TwoPhotonView(psi_out,[1,2]);\nnorm(psi_second)^2\nnorm(psi_first)^2\nnorm(psi_first_second)^2","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"Except for numerical errors, we have 50% chance of observing both photons in the same waveguide and 0 (8.736388404016349e-9)% of observing both photons in each of the waveguides simultaneously. ","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"Similarly, we can plot the scattering/splitting of a single photon arriving in the left arm. ","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"(Image: Alt text)","category":"page"},{"location":"multiplewaveguides/#Swap","page":"Multiple waveguides","title":"Swap","text":"","category":"section"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"If we instead choose V = pi  2, we get the SWAP operation. Let us consider one photon in the first waveguide and swap it to the second waveguide and animate the evolution:","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"V = pi/2\nH = im*V/dt*(wd2*w1 - wd1*w2)\npsi_out_swap = waveguide_evolution(times,ψ_single_1,H)\nfirst_after = OnePhotonView(psi_out_swap,1)\nsecond_after = OnePhotonView(psi_out_swap,2)\nnothing #hide","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"(Image: \"Alt text\")","category":"page"},{"location":"multiplewaveguides/","page":"Multiple waveguides","title":"Multiple waveguides","text":"info: WaveguideBasis(2,2,times) vs. Waveguide $\\otimes$ Waveguide\nInstead of using the custom basis for handling two waveguides, one could instead just do a tensor product between two waveguides basis. This naive approach would look something like:times = 0:0.1:10\nbw = WaveguideBasis(2,times)\nBtotal = bw ⊗ bwThis might work if you only consider single-photon excitations in the waveguides, but if you go consider two-photon excitations (as in the above) the Hilbert space blows up. Indeed, in the above example, the Hilbert space is of size: 27.594.009!!! However, since we often know that the system in total only has two excitations, there is no possibility of having two photons in both waveguides simultaneously (states of type: ket1_k1_j_1ket1_l1_m_2). This part of the Hilbert space takes up the majority since it scales as propto N^4 where N is the number of time-bins. Instead, we can exploit that only a total of two excitations is present simultaneously in the system. For this, we use the custom basis WaveguideBasis with an additional input stating the number of waveguides:bw = WaveguideBasis(2,2,times)The Hilbert space is now of size: 20706. This is still a large Hilbert space, but it is three orders of magnitude smaller than the naive approach as it only scales as propto N^2. ","category":"page"},{"location":"#WaveguideQED.jl","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"","category":"section"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"WaveguideQED.jl is a package for simulating continuous fockstates in waveguides. It expands on QuantumOptics.jl by adding a custom basis and operators for efficiently representing time-binned photon states. ","category":"page"},{"location":"#Citing","page":"WaveguideQED.jl","title":"Citing","text":"","category":"section"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"If you find the package usefull in your research. Please consider citing: https://quantum-journal.org/papers/q-2025-04-17-1710/.","category":"page"},{"location":"#Dev-docs","page":"WaveguideQED.jl","title":"Dev docs","text":"","category":"section"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"Added functionalities:","category":"page"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"WaveguideBasis for representing the waveguide Hilbert space and the related functions for generating states in this Hilbert space: zerophoton, onephoton, and twophoton. Also see OnePhotonView, TwoPhotonView, and plot_twophoton! for viewing the waveguide states and plotting them. Note that WaveguideBasis can contain multiple waveguides.\nWaveguideOperator are specialized operators allowing efficient annihilation and creation operators at each time-bin in the waveguide. They are created by giving a basis to WaveguideQED.destroy and WaveguideQED.create\nSince the interaction between the waveguide time-bin mode k and cavity/emitter is given as: a^dagger w_k - a w_k^dagger there are specially optimized functions for doing these operations called CavityWaveguideOperator which are created using a fockbasis and a waveguide basis and the functions emission and absorption.\n(OBSOLETE. SEE Beamsplitter INSTEAD). Detector, LazyTensorKet, and LazySumKet, together with detect_single_click and detect_double_click allow one to do a beamsplitter interference and subsequent detection of photons coming from two waveguides. ","category":"page"},{"location":"","page":"WaveguideQED.jl","title":"WaveguideQED.jl","text":"(Image: alt text)","category":"page"},{"location":"tutorial/#tutorial","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"In this section, we show simple examples that illustrate how to use WaveguideQED.jl in combination with QuantumOptics.jl","category":"page"},{"location":"tutorial/#combining","page":"Tutorials","title":"Combining with QuantumOptics.jl","text":"","category":"section"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Basises, states, and operators defined in WaveguideQED.jl can be effortlessly combined with operators from QuantumOptics.jl. As an example, we are going to consider a waveguide with a single photon pulse impinging on an empty onesided cavity. A sketch of the system can be seen here:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"We start by defining the basis of the cavity and waveguide:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"using WaveguideQED\nusing QuantumOptics\ntimes = 0:0.1:10\nbw = WaveguideBasis(1,times)\nbc = FockBasis(1)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Next, we want to create the Hamiltonian for the system. The interaction between the waveguide and cavity is at timestep k given by[1] H_k = i hbar sqrtgamma  Delta t( a^dagger w_k - a w_k^dagger), where a (a^dagger) is the cavity annihilation (creation) operator, w_k(w_k^dagger) is the waveguide annihilation (creation) operator, gamma is the leakage rate of the cavity, and Delta t = mathrmtimes2-mathrmtimes1 is the width of the time-bin. WaveguideQED.jl follows the same syntax as QuantumOptics.jl, and operators are defined from a basis. Operators of different Hilbert spaces are then combined using ⊗ (\\otimes) or tensor:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"a = destroy(bc)\nad = create(bc)\nw = destroy(bw)\nwd = create(bw)\ndt = times[2] - times[1]\nγ = 1\nH = im*sqrt(γ/dt)*( ad ⊗ w - a ⊗ wd  )\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"With this, we can now simulate the scattering of a single photon with a Gaussian wavefunction scattered on a cavity. We define the initial state as waveguide state as:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"ξ(t,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2)\nσ,t0 = 1,5\nψ_waveguide = onephoton(bw,ξ,σ,t0)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Note that the wavefunction xi(t) is assumed to be normalized: int_0^infty xi(t) dt = 1 when creating waveguide states. If one wants to use a non-normalized function, the keyword norm=true can be passed to onephoton to ensure normalization.","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Considering an initially empty cavity, the combined initial state is then:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"ψ_in = fockstate(bc,0) ⊗ ψ_waveguide\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"With the initial state, we can then call the solver the get the wavefunction after the interaction with the cavity.","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"ψ_out = waveguide_evolution(times,ψ_in,H)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Plotting the wavefunction and its norm square gives:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"using PyPlot\nrcParams = PyPlot.PyDict(PyPlot.matplotlib.\"rcParams\") #hide\nrcParams[\"font.size\"] = 20 #hide\nrcParams[\"font.family\"] = \"serif\" #hide\nrcParams[\"mathtext.fontset\"] =\"cm\" #hide\nviewed_state = OnePhotonView(ψ_out)\nfig,ax = subplots(1,2,figsize=(9,4.5))\nax[1].plot(times,real.(viewed_state),\"r-\",label=\"Real part\")\nax[1].set_xlabel(\"Time [a.u]\")\nax[1].set_ylabel(L\"$\\xi(t)$\")\n\nax[2].plot(times,abs.(viewed_state).^2,\"r-\")\nax[2].set_xlabel(\"Time [a.u]\")\nax[2].set_ylabel(L\"$|\\xi(t)|^2$\")\nplt.tight_layout() #hide\nplt.savefig(\"scat_onephoton.svg\") #hide\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"We see that the wavefunction has changed after the interaction with the cavity. More specifically, we see how the pulse gets absorbed into the cavity leading to a phase change in the wavefunction. This phase change also leads to destructive interference between the photon being emitted from the cavity and the reflection of the incoming photon. This leads to a dip in the photon wavefunction after the interaction.","category":"page"},{"location":"tutorial/#Expectation-values","page":"Tutorials","title":"Expectation values","text":"","category":"section"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"In the previous example, only the state at the final timestep was shown. This shows the output wavefunction, but one might also be interested in intermediate states or expectation values. Expectation values can be outputted from the solver by using the fout keyword. As an example, we can get the number of photons in the cavity as a function of time by:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"n = (ad*a) ⊗ identityoperator(bw)\nfunction exp_na(time,psi)\n    expect(n,psi)\nend\nψ_out,na = waveguide_evolution(times,ψ_in,H,fout=exp_na)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"If we also want to know the number of photons in the waveguide state as a function of time, another operator to out expectation function as:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"n = (ad*a) ⊗ identityoperator(bw)\nn_w = identityoperator(bc) ⊗ (create(bw)*destroy(bw))\nfunction exp_na_and_nw(time,psi)\n    (expect(n,psi),expect_waveguide(n_w,psi))\nend\nψ_out,na,nw = waveguide_evolution(times,ψ_in,H,fout=exp_na_and_nw)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Where expect_waveguide(n_w,psi) calculates the expectation value of all times of the pulse at each timestep: mathrmexpect_waveguide(n_wpsi) = brapsi sum_k  I otimes w_k^dagger w_k  ketpsi","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"This can be plotted as:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"fig,ax = subplots(1,1,figsize=(9,4.5))\nax.plot(times,real.(na),\"b-\",label=\"na\")\nax.plot(times,real.(nw),\"r-\",label=\"nw\")\nax.plot(times,real.(nw+na),\"g-\",label=\"na+nw\")\nax.set_xlabel(\"Time [a.u]\")\nax.set_ylabel(\"Population\")\nax.legend()\nplt.tight_layout()\nplt.savefig(\"photon_number.svg\") #hide\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Here we see how the photon wavepacket is partially absorbed into the cavity and then reemitted again.","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"If we plot the wavefunction as a function of time (and do some displacing), we can even animate the process:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/#Multiple-Photons-(2-photon-states)","page":"Tutorials","title":"Multiple Photons (2-photon states)","text":"","category":"section"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"In the above, we considered a single-photon state scattering on the cavity. If we instead want to consider more photons, we have to create a basis that allows for more photons. Currently, the maximum number of photons is two. We thus create a waveguide basis with a maximum of two photons with:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"times = 0:0.1:10\nbw = WaveguideBasis(2,times)\nbc = FockBasis(1)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"The Hamiltonian is still the same:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"w_twophoton = destroy(bw)\nwd_twophoton = create(bw)\nH_twophoton = im*sqrt(γ/dt)*( ad ⊗ w_twophoton - a ⊗ wd_twophoton  )\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"If we want an initial two-photon state, we instead use the function twophoton to create a two-photon state frac1sqrt2leftW^dagger(xi)right^20rangle = frac1sqrt2 int_t_0^t_end d t^prime int_t_0^t_end d t  xi^(2)(tt) w^dagger(t) w^daggerleft(t^primeright)0rangle  (see Theory(ref theory) for details) In the following we define the two-photon wavefunction xi^(2)(tt) = xi^(1)(t)xi^(1)(t) which is thus a product state of two single-photons. ","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"ξ2(t1,t2,σ,t0) = ξ(t1,σ,t0)*ξ(t2,σ,t0)\nσ,t0 = 1,5\nψ_twophoton = 1/sqrt(2)*twophoton(bw,ξ2,σ,t0)\nψ_in_twophoton = fockstate(bc,0) ⊗ ψ_twophoton\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Notice the structure of ξ2(t1,t2,σ,t0), it now has two time-arguments and the remaining arguments are parameters. If we wanted to allow for two different widths of the single-photon states in the product state, we could have also defined: ξ2(t1,t2,σ1,σ2,t0) = ξ(t1,σ1,t0)*ξ(t2,σ2,t0). Another important detail is the normalization. twophoton only creates int_t_0^t_end d t^prime int_t_0^t_end d t  xi^(2)(tt) w^dagger(t) w^dagger left( t^prime right)  0 rangle and we thus need the factor of 1sqrt2 for the state to be normalized. ","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"In the following, we consider the more simple case of equivalent photons. We solve the two-photon scattering in the following.","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"ψ_out = waveguide_evolution(times,ψ_in_twophoton,H_twophoton)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"The resulting scattered two-photon state can be retrieved with the TwoPhotonView structure.","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"ψ_out_twophoton = TwoPhotonView(ψ_out)\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"We can plot the two-photon state easily with:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"fig,ax = subplots(1,1,figsize=(9,4.5))\nplot_twophoton!(ax,ψ_out_twophoton,times)\nax.set_xlabel(L\"$t_1$ [$1/\\gamma$]\")\nax.set_ylabel(L\"$t_2$ [$1/\\gamma$]\")\nplt.tight_layout() #hide\nplt.savefig(\"twophoton_scat.svg\") #hide\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Note that per default, the view structures (OnePhotonView and TwoPhotonView) pick out the groundstate of all the other bases, which in this case means that we are viewing the state ketpsi = ket0 otimes sum_k sum_j xi^(2)(tt) Delta t w_k^dagger w_j^dagger ketemptyset. If instead, we wanted to view  ketpsi = ket1 otimes sum_k sum_j xi^(2)(tt) Delta t w_k^dagger w_j^dagger ketemptyset, we can give and extra indexing argument. In this case, the first basis belongs to the cavity and the state ket1 has the index 2, while the second basis is the waveguide basis and we here want the whole state so we give the index \":\". We thus have:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"ψ_out_twophoton_upper = TwoPhotonView(ψ_out,[2,:])\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"Since all photons have leaked out of the cavity at the end of the simulation, this state is almost unoccupied which we can see by:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"println(norm(ψ_out_twophoton_upper)^2)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"and if we plot it, we also get nothing:","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"fig,ax = subplots(1,1,figsize=(9,4.5))\nplot_twophoton!(ax,ψ_out_twophoton_upper,times)\nax.set_xlabel(L\"$t_1$ [$1/\\gamma$]\")\nax.set_ylabel(L\"$t_2$ [$1/\\gamma$]\")\nplt.tight_layout() #hide\nplt.savefig(\"twophoton_scat2.svg\") #hide","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"(Image: alt text)","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"[1]: [1]","category":"page"}]
}
