<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Detection and Projections · WaveguideQED.jl</title><meta name="title" content="Detection and Projections · WaveguideQED.jl"/><meta property="og:title" content="Detection and Projections · WaveguideQED.jl"/><meta property="twitter:title" content="Detection and Projections · WaveguideQED.jl"/><meta name="description" content="Documentation for WaveguideQED.jl."/><meta property="og:description" content="Documentation for WaveguideQED.jl."/><meta property="twitter:description" content="Documentation for WaveguideQED.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">WaveguideQED.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">WaveguideQED.jl</a></li><li><a class="tocitem" href="../theoreticalbackground/">Theoretical Background</a></li><li><a class="tocitem" href="../tutorial/">Tutorials</a></li><li><a class="tocitem" href="../multiplewaveguides_v2/">Multiple Waveguides</a></li><li><a class="tocitem" href="../beamsplitter/">Beamsplitters</a></li><li><a class="tocitem" href="../input_output/">Input-Output Relations</a></li><li><a class="tocitem" href="../time_delay/">Non-Markovian dynamics</a></li><li><a class="tocitem" href="../gpu_support/">GPU Support</a></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../references/">References and suggested readings</a></li><li><span class="tocitem">Experimental or Outdated functionalities</span><ul><li class="is-active"><a class="tocitem" href>Detection and Projections</a><ul class="internal"><li><a class="tocitem" href="#Background-Theory"><span>Background Theory</span></a></li><li><a class="tocitem" href="#Beamsplitter-and-detection-in-WaveguideQED.jl"><span>Beamsplitter and detection in WaveguideQED.jl</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Experimental or Outdated functionalities</a></li><li class="is-active"><a href>Detection and Projections</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Detection and Projections</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/qojulia/WaveguideQED.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/qojulia/WaveguideQED.jl/blob/main/docs/src/detection.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="BStutorial"><a class="docs-heading-anchor" href="#BStutorial">Detection and Projections</a><a id="BStutorial-1"></a><a class="docs-heading-anchor-permalink" href="#BStutorial" title="Permalink"></a></h1><p>A beamsplitter is a partly reflective, partly transmissive mirror that splits up an incoming photon, as depicted here. </p><p><img src="../illustrations/single_beamsplitter.png" alt="beamsplitter"/></p><p>Assuming that the beamsplitter is equal (50% transmission and 50% reflection) and that we have only a single photon in one of waveguides impinging on the beamsplitter, the photon will go to detector plus 50% of the time and detector minus the other 50% of the time. This can be modeled in <code>WaveguideQED.jl</code> using <a href="../API/#WaveguideQED.LazyTensorKet"><code>LazyTensorKet</code></a> and <a href="../API/#WaveguideQED.Detector"><code>Detector</code></a>. We start by creating the two input waveguides.   </p><h2 id="Background-Theory"><a class="docs-heading-anchor" href="#Background-Theory">Background Theory</a><a id="Background-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Background-Theory" title="Permalink"></a></h2><p>Two photons impinging on a beamsplitter is a classic example of destructive and constructive interference. If the two photons are indistinguishable, they will always appear in pairs on the other side of the beamsplitter. That is the following scenario:  </p><p><img src="../illustrations/hong_au_mandel.png" alt="beamsplitter"/></p><p>However, what happens if the two photons have a slight mismatch in frequency or their temporal distribution, and how do we model this? Assuming the beamsplitter is 50/50 the beamsplitter transformation is<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>  : <span>$w_a \rightarrow (w_c + w_d)/\sqrt(2)$</span> and <span>$w_b \rightarrow (w_c - w_d)/\sqrt(2)$</span>, where <span>$w_k$</span> is the annihilation operator for waveguide <span>$k=\{a,b,c,d\}$</span>. A one photon continuous fockstate in waveguide a and b with wavefunction <span>$\xi_a(t)$</span> and <span>$\xi_b(t)$</span> has the combined state:</p><p class="math-container">\[\begin{align*}
\ket{\psi}_{a,b} &amp;= \ket{\psi}_a \otimes \ket{\psi}_b =  \int_{t_0}^{t_{end}} \mathrm{d}t \ \xi_a(t) w_a^\dagger(t) \ket{0}_a \otimes \int_{t_0}^{t_{end}} \mathrm{d}t \ \xi_b(t) w_b^\dagger(t) \ket{0}_b \\
&amp; \int_{t_0}^{t_{end}} \mathrm{d}t \int_{t_0}^{t_{end}} \mathrm{d}t&#39; \xi_a(t)\xi_b(t&#39;) w_a^\dagger(t)  w_b^\dagger(t&#39;) \ket{0}_a\ket{0}_b
\end{align*}\]</p><p>Using the beamsplitter transformation, we thus have the following state after the two photons have interfered with the beamsplitter:</p><p class="math-container">\[\begin{align*}
\ket{\psi}_{a,b} &amp;\xrightarrow[]{BS} \frac{1}{2}  \int_{t_0}^{t_{end}} \mathrm{d}t \int_{t_0}^{t_{end}} \mathrm{d}t&#39; \xi_a(t)\xi_b(t&#39;) (w_c^\dagger(t) + w_d^\dagger(t))  (w_c^\dagger(t&#39;) - w_d^\dagger(t&#39;)) \ket{0}_a\ket{0}_b \\
&amp;=  \frac{1}{2}  \int_{t_0}^{t_{end}} \mathrm{d}t \int_{t_0}^{t_{end}} \mathrm{d}t&#39; \xi_a(t)\xi_b(t&#39;) \left [ w_c^\dagger(t) w_c^\dagger(t&#39;) + w_d^\dagger(t)w_c^\dagger(t&#39;) - w_c^\dagger(t)w_d^\dagger(t&#39;) - w_d^\dagger(t)w_d^\dagger(t&#39;) \right ] \ket{0}_c\ket{0}_d \\
&amp;= \frac{1}{2} \left ( W_c^\dagger(\xi_a) W_c^\dagger(\xi_b) \ket{0}_c - W_d^\dagger(\xi_a) W_d^\dagger(\xi_b) \ket{0}_d + \int_{t_0}^{t_{end}} \mathrm{d}t \int_{t_0}^{t_{end}} \mathrm{d}t&#39; \left [ \xi_a(t)\xi_b(t&#39;) - \xi_a(t&#39;)\xi_b(t) \right] \ket{1}_c\ket{1}_d \right)
\end{align*}\]</p><p>where we introduced <span>$W_{c/d}^\dagger(\xi_a) W_{c/d}^\dagger(\xi_b) \ket{0}_{c/d} = int_{t_0}^{t_{end}} \mathrm{d}t \int_{t_0}^{t_{end}} \mathrm{d}t&#39; \xi_a(t)\xi_b(t&#39;) w_{c/d}^\dagger(t) w_{c/d}^\dagger(t&#39;) \ket{0}_{c/d}$</span>. <span>$W_{c/d}^\dagger(\xi_a) W_{c/d}^\dagger(\xi_b) \ket{0}_{c/d}$</span> thus corresponds to both photons going into the same direction. It is also evident that if <span>$\xi_a(t)\xi_b(t&#39;) - \xi_a(t&#39;)\xi_b(t) = 0$</span> then we will have no photons in waveguide c and d simultaneously. This condition is exactly fulfilled if the photon in waveguide a is indistinguishable from the photon in waveguide b. This also means that if the photons ARE distinguishable, we will start to see photons occurring in waveguides c and d simultaneously. All this and more can be simulated in the code, and in the next section, we walk through how to set the above example up in the code.</p><h2 id="Beamsplitter-and-detection-in-WaveguideQED.jl"><a class="docs-heading-anchor" href="#Beamsplitter-and-detection-in-WaveguideQED.jl">Beamsplitter and detection in WaveguideQED.jl</a><a id="Beamsplitter-and-detection-in-WaveguideQED.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Beamsplitter-and-detection-in-WaveguideQED.jl" title="Permalink"></a></h2><p>In <code>WaveguideQED.jl</code> we create the two incoming photons in each of their respective waveguides and define the corresponding annihilation operators:</p><pre><code class="language-julia hljs">times = 0:0.1:20
bw = WaveguideBasis(1,times)
ξfun(t,σ,t0) = complex(sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t-t0)^2/σ^2))
waveguide_a = onephoton(bw,ξfun,1,10)
waveguide_b = onephoton(bw,ξfun,1,10)
wa = destroy(bw)
wb = destroy(bw)</code></pre><p>We then combine the states of waveguide a and b in a lazy tensor structure (tensor product is never calculated, but the dimensions are inferred in subsequent calculations):</p><pre><code class="language-julia hljs">ψ_total = LazyTensorKet(waveguide_a,waveguide_b)</code></pre><p>Now we define <a href="../API/#WaveguideQED.Detector"><code>Detector</code></a> operators, which define the beamsplitter and subsequent detection operation. In the following <span>$\mathrm{Dplus} = D_+ = \frac{1}{\sqrt{2}}(w_a + w_b) $ and $\mathrm{Dminus} = D_- = \frac{1}{\sqrt{2}}(w_a - w_b)$</span></p><pre><code class="language-julia hljs">Dplus = Detector(wa/sqrt(2),wb/sqrt(2))
Dminus = Detector(wa/sqrt(2),-wb/sqrt(2))</code></pre><p>The <a href="../API/#WaveguideQED.Detector"><code>Detector</code></a> applies the first operator (<code>wa/sqrt(2)</code>) to the first <code>Ket</code> in LazyTensorKet (<code>waveguide_a</code>) and the second operator ($\pm $ <code>wb/sqrt(2)</code>) to the second <code>Ket</code> in <code>LazyTensorKet</code> (waveguide_b). The probability of detecting a photon in the detectors can then be calculated by:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p_plus = Dplus * ψ_total</code><code class="nohighlight hljs ansi" style="display:block;">0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p_minus = Dminus * ψ_total</code><code class="nohighlight hljs ansi" style="display:block;">0.0</code></pre><p>The returned probabilities are zero because there is no states that result in only ONE click at the detectors. Instead, we have to ask for the probability of detecting TWO photons:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p_plus_plus = Dplus * Dplus * ψ_total</code><code class="nohighlight hljs ansi" style="display:block;">0.4999999999999996</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p_minus_minus = Dminus * Dminus * ψ_total</code><code class="nohighlight hljs ansi" style="display:block;">0.4999999999999996</code></pre><p>Notice that we here asked what the probability of having a detection event in detector plus/minus and, subsequently, another detection event in detector plus/minus is. The output was <span>$50\%$</span> for both cases reflecting the above calculations where we would expect the two photons always come in pairs. As a consequence, the probability of having a click in detector plus and then in detector minus (or vice versa) is given as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p_plus_minus = Dplus * Dminus * ψ_total</code><code class="nohighlight hljs ansi" style="display:block;">0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p_minus_plus = Dminus * Dplus * ψ_total</code><code class="nohighlight hljs ansi" style="display:block;">0.0</code></pre><p>As expected, the resulting probabilities are zero. If we instead displace the photons in time so that one is centered around <span>$t = 5$</span> and another around <span>$t = 15$</span> we get:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; waveguide_a = onephoton(bw,ξfun,1,5);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; waveguide_b = onephoton(bw,ξfun,1,15);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ψ_total = LazyTensorKet(waveguide_a,waveguide_b);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p_plus_plus = Dplus * Dplus * ψ_total</code><code class="nohighlight hljs ansi" style="display:block;">0.24999999999999978</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p_minus_minus = Dminus * Dminus * ψ_total</code><code class="nohighlight hljs ansi" style="display:block;">0.24999999999999978</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p_plus_minus = Dplus * Dminus * ψ_total</code><code class="nohighlight hljs ansi" style="display:block;">0.24999999999999978</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p_minus_plus = Dminus * Dplus * ψ_total</code><code class="nohighlight hljs ansi" style="display:block;">0.24999999999999978</code></pre><p>Thus we have an equal probability of detection events in the same detector and opposite detectors since the two photon-pulses are temporarily separated.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>[<a href="../references/#Gerry2004">14</a>]</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../references/">« References and suggested readings</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Thursday 20 March 2025 07:22">Thursday 20 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
