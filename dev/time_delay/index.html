<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Non-Markovian dynamics · WaveguideQED.jl</title><meta name="title" content="Non-Markovian dynamics · WaveguideQED.jl"/><meta property="og:title" content="Non-Markovian dynamics · WaveguideQED.jl"/><meta property="twitter:title" content="Non-Markovian dynamics · WaveguideQED.jl"/><meta name="description" content="Documentation for WaveguideQED.jl."/><meta property="og:description" content="Documentation for WaveguideQED.jl."/><meta property="twitter:description" content="Documentation for WaveguideQED.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">WaveguideQED.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">WaveguideQED.jl</a></li><li><a class="tocitem" href="../theoreticalbackground/">Theoretical Background</a></li><li><a class="tocitem" href="../tutorial/">Tutorials</a></li><li><a class="tocitem" href="../multiplewaveguides_v2/">Multiple Waveguides</a></li><li><a class="tocitem" href="../beamsplitter/">Beamsplitters</a></li><li><a class="tocitem" href="../input_output/">Input-Output Relations</a></li><li class="is-active"><a class="tocitem" href>Non-Markovian dynamics</a><ul class="internal"><li><a class="tocitem" href="#feedback"><span>Waveguide and Mirror</span></a></li><li><a class="tocitem" href="#emitters"><span>Spatially separated emitters</span></a></li></ul></li><li><a class="tocitem" href="../gpu_support/">GPU Support</a></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../references/">References and suggested readings</a></li><li><span class="tocitem">Experimental or Outdated functionalities</span><ul><li><a class="tocitem" href="../detection/">Detection and Projections</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Non-Markovian dynamics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Non-Markovian dynamics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/qojulia/WaveguideQED.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/qojulia/WaveguideQED.jl/blob/main/docs/src/time_delay.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Non-Markovian-dynamics"><a class="docs-heading-anchor" href="#Non-Markovian-dynamics">Non-Markovian dynamics</a><a id="Non-Markovian-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Markovian-dynamics" title="Permalink"></a></h1><p>Non-Markovian dynamics or memory effects can arise in waveguide QED systems when the emitted light is reflected back into the system or when considering two spatially separated emitters. Waveguide systems with memory effects constitute a challenging class of problems because knowledge of the emitted field is inherently required to capture the correct feedback. In the <strong>WaveguideQED</strong> framework, we describe the entirety of the emitted field, which enables a straightforward treatment of memory effects, which we showcase below.</p><h2 id="feedback"><a class="docs-heading-anchor" href="#feedback">Waveguide and Mirror</a><a id="feedback-1"></a><a class="docs-heading-anchor-permalink" href="#feedback" title="Permalink"></a></h2><p>As an example of a system with memory effects, we consider a Semi-Infinite Waveguide terminating with a mirror in one end, as also depicted below. The mirror will here introduce a face shift <span>$\phi$</span>, but also an excitation emitted in the left mode will, after a delay time of <span>$\tau/2$</span>, be reflected into the right mode and thus, after a total delay time of <span>$\tau$</span> hit the emitter again.</p><p><img src="../illustrations/mirror_feedback.svg" alt="alt text"/></p><p>The left and right propagating modes are here symmetrical [<a href="../references/#HughesWQEDMPP2021">5</a>], and one can instead think of a single mode wrapping around the emitter. The waveguide is thus a &quot;horseshoe&quot;, and the emitter couples to two points of the horseshoe. The two points are here seperated in time ensuring the feedback mechanism. This is also illustrated below.</p><p><img src="../illustrations/horseshoe.svg" alt="alt text"/></p><p>With this mental picture, there is only one propagating mode, and we describe the interaction through the Hamiltonian [<a href="../references/#Whalen2019">6</a>]:</p><p class="math-container">\[\begin{equation}
H_k = \mathrm{e}^{i \phi} \sqrt{\gamma/2\Delta t} \left( \sigma^\dagger w_{k} + \sigma w_{k}^\dagger \right) + \sqrt{\gamma/2\Delta t} \left( \sigma^\dagger w_{k+\tilde{\tau}} + \sigma w_{k+\tilde{\tau}}^\dagger \right)
\end{equation}\]</p><p>where <span>$\tilde{\tau} = \tau/\Delta t$</span> is the index necessary to introduce a time-delay of <span>$\tau$</span> between the emission and reabsorption. Note that it is the operator <span>$w_{k+\tilde{\tau}}$</span> that never &quot;sees&quot; the emitted photon again (thus corresponding to the left propagating mode in the first figure, whereas the operator <span>$w_{k}$</span> experiences the emitted photon from <span>$\tilde{\tau}$</span> time steps ago (and thus corresponds to the right propagating mode).  <span>$w_{k}^\dagger$</span> and <span>$w_{k}$</span> thus carry the phase factor <span>$\mathrm{e}^{i \phi}$</span> from the mirror.</p><p>This type of Hamiltonian is easily described in the <strong>WaveguideQED</strong> framework. We can here create &quot;delayed&quot; operators that address time bins at a delayed time, thus corresponding to <span>$w_{k+\tilde{\tau}}$</span>. This can be done with the keyword <code>delay</code> when creating the operator that determines how many bins the delay should be. The value <code>delay</code> should therefore be an integer corresponding to <span>$\tilde{\tau} = \tau/\Delta t$</span>. In the following, we define <span>$w_{k+\tilde{\tau}}$</span> as <code>w_delayed</code>:</p><pre><code class="language-julia hljs">times = 0:0.1:11
dt = times[2]-times[1]
bw = WaveguideBasis(1,times)

delay_time = 1
w_delayed = destroy(bw;delay=delay_time/dt)
wd_delayed = create(bw;delay=delay_time/dt)</code></pre><p>The delayed operators are just normal WaveguideOperators addressing different time-bins and can, therefore, effortlessly be combined with the operators of the emitter:</p><pre><code class="language-julia hljs">be = FockBasis(1)
sdw_delayed = create(be) ⊗ w_delayed
wds_delayed = destroy(be) ⊗ wd_delayed</code></pre><p>We can then create the non-delayed operators. We also define the Hamiltonian with a leakage rate of <span>$\gamma = 1$</span> and a mirror phase of <span>$\pi$</span>:</p><pre><code class="language-julia hljs">gamma = 1
phi = pi

sdw = create(be) ⊗ destroy(bw)
wds = destroy(be) ⊗ create(bw)

H_pi = exp(im*phi)*sqrt(gamma/2/dt)*(sdw+wds)+sqrt(gamma/2/dt)*(sdw_delayed+wds_delayed)</code></pre><p>Considering then how an initially excited emitter population decays, we create the expectation function <code>ne_exp</code> returning the emitter population and define the initial state. </p><pre><code class="language-julia hljs">sd = create(be) ⊗ identityoperator(bw)
s = destroy(be) ⊗ identityoperator(bw)
n = sd*s
function ne_exp(time,psi)
    expect(n,psi)
end

psi_initial = fockstate(be,1) ⊗ zerophoton(bw)</code></pre><p>Finally, we can solve the dynamics of the system and plot them.</p><pre><code class="language-julia hljs">_,ne_pi = waveguide_evolution(times, psi_initial, H_pi,fout=ne_exp)</code></pre><pre><code class="language-julia hljs">fig,ax = subplots(1,1,figsize=(9,4.5))
ax.plot(times,real.(ne_pi),&quot;r-&quot;)
ax.set_xlabel(L&quot;time [$1/\gamma$]&quot;)
ax.set_ylabel(&quot;Population&quot;)</code></pre><p><img src="../feedback_pi.svg" alt="alt text"/></p><p>Here, we observe excitation trapping, where destructive interference from the mirror phase, prevents any excitation from going to the right after the initial feedback loop (notice the kink around <span>$t=1$</span>). This is a typical effect observed in these feedback systems, see [<a href="../references/#HughesWQEDMPP2021">5</a>]. Note that we observe an artifact in the simulation from <span>$t=10$</span> to <span>$t=11$</span> because the delayed operators are trying to address bins in the future which do not exist. To prevent such spurious results from appearing we can instead simulate for a shorter time such that the delay of the operators never exceed the time-bins over which the waveguide basis is defined. We illustrate this in the following by considering a mirror phase of <span>$\phi =0$</span> and only simulate until <span>$t=10$</span>:</p><pre><code class="language-julia hljs">phi = 0
H_zero = exp(im*phi)*sqrt(gamma/2/dt)*(sdw+wds)+sqrt(gamma/2/dt)*(sdw_delayed+wds_delayed)

times_sim = 0:0.1:10
_,ne_0 = waveguide_evolution(times_sim, psi_initial, H_zero,fout=ne_exp)</code></pre><p>This gives the plot:</p><pre><code class="language-julia hljs">fig,ax = subplots(1,1,figsize=(9,4.5))
ax.plot(times_sim,real.(ne_pi[1:end-10]),&quot;r-&quot;,label=L&quot;$\phi = \pi, \ \ \ \tau= 1$&quot;)
ax.plot(times_sim,real.(ne_0),&quot;b-&quot;,label=L&quot;$\phi = 0, \ \ \ \tau= 1$&quot;)
ax.plot(times_sim,real.(exp.(-times_sim)),&quot;k--&quot;,label=L&quot;$\tau= \infty$&quot;)
ax.set_xlabel(L&quot;time [$1/\gamma$]&quot;)
ax.set_ylabel(&quot;Population&quot;)
ax.legend()</code></pre><p><img src="../feedback_0.svg" alt="alt text"/></p><p>For comparison, we here also plotteds an exponential decay with the rate <span>$\gamma$</span> which corresponds to an infinite delay time. We see that for <span>$\phi=0$</span> we have constructive interference for the excitation going to the right and the population of the emitter decays faster than had there been no feedback.</p><h2 id="emitters"><a class="docs-heading-anchor" href="#emitters">Spatially separated emitters</a><a id="emitters-1"></a><a class="docs-heading-anchor-permalink" href="#emitters" title="Permalink"></a></h2><p>Another interesting configuration to investigate is two spatially seperated emitters. If the separation between the emitters <span>$\tau$</span> is comparable to the emission time <span>$1/\gamma$</span>, then a full description of the waveguide state is necessary. A sketch of the considered system can be seen here:</p><p><img src="../illustrations/emitters_delay.svg" alt="alt text"/></p><p>An emission from emitter A thus arrives at emitter B via the waveguide after <span>$\tau$</span> time and vice versa. We can represent this in the <code>Waveguide.jl</code> formalism as a looped conveyor belt, where the two emitters interact with the waveguide or conveyor belt at two different times/places. This is illustrated below:</p><p><img src="../illustrations/emitters_circle.png" alt="alt text"/></p><p>We can create such a loop by using delayed operators. This way, the two emitters interact with the same waveguide in different time bins. The waveguide operators, per default, loop around themselves, and thus, by placing the delayed emitter exactly in the middle of the waveguide state, we recreate the loop above. This is also illustrated here:</p><p><img src="../illustrations/emitters_delay_box.svg" alt="alt text"/></p><p>Here, the looping mechanism is illustrated as &quot;portals&quot; that move the waveguide state&#39;s last box to the waveguide&#39;s beginning whenever the end is reached due to the progression of time. We thus create a waveguide basis with a length of <span>$2 \tau$</span> and a set of waveguide operators which are delayed by <span>$\tau$</span>:</p><pre><code class="language-julia hljs">tau = 10
dt = 0.1
times = 0:dt:2*tau+dt
bw = WaveguideBasis(1, times) #waveguide basis
be = FockBasis(1) #emitter basis

#Defining operators
w = destroy(bw)
wd = create(bw)
w_tau = destroy(bw; delay=tau/dt+1)#Delay of tau
wd_tau = create(bw; delay=tau/dt+1)#Delay of tau
sd = create(be) #Emitter operator
s = destroy(be) #Emitter operator
Iw = identityoperator(bw) #Identityoperator
Ie = identityoperator(be) #Identityoperator</code></pre><p>We can then create the Hamiltonian, where emitter A interacts with the not-delayed operators and emitter B with the delayed operators. We also create the expectation value operators here: </p><pre><code class="language-julia hljs">γ = 1
H_e1 = im*sqrt(γ/dt)*(sd⊗Ie⊗w - s⊗Ie⊗wd)
H_e2 = im*sqrt(γ/dt)*(Ie⊗sd⊗w_tau - Ie⊗s⊗wd_tau)
H = H_e1 + H_e2

ne_a = (sd*s)⊗Ie⊗Iw
ne_b = Ie⊗(sd*s)⊗Iw
nw = Ie⊗Ie⊗(wd*w)
function expval(time, psi)
  expect(ne_a, psi), expect(ne_b, psi), expect_waveguide(nw, psi)
end</code></pre><p>Finally, we can simulate the emission of a photon from emitter A, which, after a delay, impinges on emitter B:</p><pre><code class="language-julia hljs">times_sim = 0:dt:2*tau
ψ = fockstate(be, 1) ⊗ fockstate(be, 0) ⊗ zerophoton(bw)
ψ, e1, e2, ew = waveguide_evolution(times_sim, ψ, H, fout=expval)

fig,ax = subplots(1,1,figsize=(9,4.5))
ax.plot(times_sim, abs.(e1), label=&quot;Emitter A&quot;)
ax.plot(times_sim, abs.(e2), label=&quot;Emitter B&quot;)
ax.plot(times_sim, abs.(ew), label=&quot;Waveguide&quot;)
ax.set_xlabel(L&quot;Time [$1/\gamma$]&quot;)
ax.set_ylabel(&quot;Population&quot;)
tight_layout()
ax.legend()</code></pre><p><img src="../e1_excited.svg" alt="alt text"/></p><p>In the above, we see emitter A decay and emitter B absorps the emitted photon, albeit not entirely. In reality, part of the incoming pulse from emitter A will reflect, and part of it will be absorbed. This means that if we run the simulation for a longer period, we will see emitter A being excited before emitter B is finished emitting. We can show this by extending the simulation time to <span>$6 \tau$</span>:</p><pre><code class="language-julia hljs">times_sim = 0:dt:8*tau
ψ = fockstate(be, 1) ⊗ fockstate(be, 0) ⊗ zerophoton(bw)
ψ, e1, e2, ew = waveguide_evolution(times_sim, ψ, H, fout=expval)

fig,ax = subplots(1,1,figsize=(9,4.5))
ax.plot(times_sim, abs.(e1), label=&quot;Emitter A&quot;)
ax.plot(times_sim, abs.(e2), label=&quot;Emitter B&quot;)
ax.plot(times_sim, abs.(ew), label=&quot;Waveguide&quot;)
ax.set_xlabel(L&quot;Time [$1/\gamma$]&quot;)
ax.set_ylabel(&quot;Expectation Value&quot;)
tight_layout()
ax.legend()</code></pre><p><img src="../e1_excited_slushing.svg" alt="alt text"/></p><p>Here, we see the pulse doing multiple roundtrips, and the excitation of the emitters gets more and more complicated as reflections and reflections of reflections interfere. We see that as more round trips are completed, there is a simultaneous excitation of emitter A and B, indicating the non-trivial nature of the feedback loop. This gets even more complicated if one considers a lifetime of the emitters <span>$1/\gamma$</span> that is longer than the delay <span>$1/\tau$</span>.</p><p>One could also consider both emitters being excited in the beginning. This is done by allowing the waveguide to have two photons in it and changing the initial state. However, if there is no difference between the emitters, we will just see a completely symmetric excitation of them both, as the photons bounce back and forth. In the following, we thus consider two different decay rates of the emitters:</p><pre><code class="language-julia hljs">bw = WaveguideBasis(2, times) #waveguide basis with twophotons

γ = 1
H_e1 = im*sqrt(γ/dt)*(sd⊗Ie⊗w - s⊗Ie⊗wd)
H_e2 = im*sqrt(γ/dt/2)*(Ie⊗sd⊗w_tau - Ie⊗s⊗wd_tau)
H = H_e1 + H_e2


times_sim = 0:dt:6*tau
ψ = fockstate(be, 1) ⊗ fockstate(be, 1) ⊗ zerophoton(bw)
ψ, e1, e2, ew = waveguide_evolution(times_sim, ψ, H, fout=expval)

fig,ax = subplots(1,1,figsize=(9,4.5))
ax.plot(times_sim, abs.(e1), label=&quot;Emitter A&quot;)
ax.plot(times_sim, abs.(e2), label=&quot;Emitter B&quot;)
ax.plot(times_sim, abs.(ew), label=&quot;Waveguide&quot;)
ax.set_xlabel(L&quot;Time [$1/\gamma$]&quot;)
ax.set_ylabel(&quot;Expectation Value&quot;)
tight_layout()
ax.legend()</code></pre><p><img src="../both_excited.svg" alt="alt text"/></p><p>Here, we see that emitter A, which has a larger decay rate than emitter B, quickly decays so that emitter B is reexcited before it is fully de-excited. Afterward, the evolution quickly grows complicated due to the multiple scattering events. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../input_output/">« Input-Output Relations</a><a class="docs-footer-nextpage" href="../gpu_support/">GPU Support »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 30 November 2025 03:55">Sunday 30 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
