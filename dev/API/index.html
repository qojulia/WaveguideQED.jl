<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · WaveguideQED.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">WaveguideQED.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">WaveguideQED.jl</a></li><li><a class="tocitem" href="../theoreticalbackground/">Theoretical Background</a></li><li><a class="tocitem" href="../tutorial/">Tutorials</a></li><li><a class="tocitem" href="../multiplewaveguides_v2/">Multiple Waveguides</a></li><li><a class="tocitem" href="../input_output/">Input-Output Relations</a></li><li><a class="tocitem" href="../time_delay/">Non-Markovian dynamics</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Autogenerated-API-list"><span>Autogenerated API list</span></a></li></ul></li><li><a class="tocitem" href="../references/">References and suggested readings</a></li><li><span class="tocitem">Experimental or Outdated functionalities</span><ul><li><a class="tocitem" href="../detection/">Detection and Projections</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/qojulia/WaveguideQED.jl/blob/main/docs/src/API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-API"><a class="docs-heading-anchor" href="#Full-API">Full API</a><a id="Full-API-1"></a><a class="docs-heading-anchor-permalink" href="#Full-API" title="Permalink"></a></h1><style>
    .content table td {
        padding-top: 0 !important;
        padding-bottom: 0 !important;
    }
</style><h2 id="Autogenerated-API-list"><a class="docs-heading-anchor" href="#Autogenerated-API-list">Autogenerated API list</a><a id="Autogenerated-API-list-1"></a><a class="docs-heading-anchor-permalink" href="#Autogenerated-API-list" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.CavityWaveguideAbsorption" href="#WaveguideQED.CavityWaveguideAbsorption"><code>WaveguideQED.CavityWaveguideAbsorption</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CavityWaveguideAbsorption{B1,B2} &lt;: CavityWaveguideOperator{B1,B2}</code></pre><p>Structure for fast simultaneous Cavity creation and Waveguide annihilation operator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/CavityWaveguideOperator.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.CavityWaveguideEmission" href="#WaveguideQED.CavityWaveguideEmission"><code>WaveguideQED.CavityWaveguideEmission</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CavityWaveguideEmission{B1,B2} &lt;: CavityWaveguideOperator{B1,B2}</code></pre><p>Structure for fast simultaneous cavity annihilation and waveguide creation operator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/CavityWaveguideOperator.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.CavityWaveguideOperator" href="#WaveguideQED.CavityWaveguideOperator"><code>WaveguideQED.CavityWaveguideOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type used for operators on acting on a combined <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> and cavity basis (<code>FockBasis</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/CavityWaveguideOperator.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.Detector" href="#WaveguideQED.Detector"><code>WaveguideQED.Detector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Detector(wa,wb)</code></pre><p>Detector operation defined by giving waveguide annihilation operator <code>wa</code> and <code>wb</code> from two subsystems. <code>wa</code> acts on the first subsystem of a <a href="#WaveguideQED.LazyTensorKet"><code>LazyTensorKet</code></a> or <a href="#WaveguideQED.LazySumKet"><code>LazySumKet</code></a> and <code>wb</code> on the second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/detection.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.LazySumKet" href="#WaveguideQED.LazySumKet"><code>WaveguideQED.LazySumKet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LazySumKet(kets...)</code></pre><p>Lazy sum of LazyTensorKets that is used to express entanglement between subsystems in LazyTensorKets. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/detection.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.LazyTensorBra" href="#WaveguideQED.LazyTensorBra"><code>WaveguideQED.LazyTensorBra</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LazyTensorBra(bras)</code></pre><p>Lazy tensor product between bras. Used in functions for beamsplitter and subsequent detection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/detection.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.LazyTensorKet" href="#WaveguideQED.LazyTensorKet"><code>WaveguideQED.LazyTensorKet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LazyTensorKet(kets)</code></pre><p>Lazy tensor product between kets. Used in functions for beamsplitter and subsequent detection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/detection.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.OnePhotonView" href="#WaveguideQED.OnePhotonView"><code>WaveguideQED.OnePhotonView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OnePhotonView{T} &lt;: AbstractVector{T}</code></pre><p>Structure for viewing onephoton excitations in waveguides of the form <span>$W^\dagger(\xi) |0 \rangle = \int_{t_0}^{t_{end}} dt  \xi(t) w_{\mathrm{i}}^\dagger(t) |\emptyset \rangle$</span> where <span>$i$</span> is the index of the waveguide. See <a href="#WaveguideQED.onephoton"><code>onephoton</code></a> on how to create onephoton wavepackets and <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a> on how to index when there are multiple systems.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using QuantumOptics;
times = 0:1:10;
bw = WaveguideBasis(1,times);
ψ1 = onephoton(bw,x-&gt;1,norm=false);
OnePhotonView(ψ1) == ones(length(times))</code></pre><pre><code class="language- hljs">bc = FockBasis(2);
ψ1Cavity = fockstate(bc,2,norm=false) ⊗ ψ1;
OnePhotonView(ψCavity,[3,:]) == ones(length(times))</code></pre><pre><code class="language- hljs">bw =  WaveguideBasis(1,3,times);
ψ2 = onephoton(bw,2,x-&gt;1,norm=false)
OnePhotonView(ψ,2) == ones(length(times))</code></pre><pre><code class="language- hljs">ψ2Cavity = fockstate(bc,2) ⊗ ψ2;
OnePhotonView(ψ2Cavity,2,[3,:]) == ones(length(times))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L88-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.OnePhotonView-Tuple{T} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np}))" href="#WaveguideQED.OnePhotonView-Tuple{T} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np}))"><code>WaveguideQED.OnePhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OnePhotonView(ψ::T) where {T&lt;:SingleWaveguideKet}</code></pre><p>ψ contains only a single waveguide and no waveguide index is needed. No index of the system is provided and groundstate is assumed.  Thus returns <code>OnePhotonView(ψ,index)</code> with <code>index = [1,:,1,...]</code> with <code>:</code> at the location of the waveguide and 1 in every other position. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L134-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.OnePhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, Int64, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I&lt;:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}" href="#WaveguideQED.OnePhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, Int64, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I&lt;:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}"><code>WaveguideQED.OnePhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OnePhotonView(ψ::T,WI::Int,index::I) where {T&lt;:MultipleWaveguideKet,I&lt;:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}</code></pre><p>ψ contains only a multiple waveguides and waveguide index <code>WI</code> is needed. <code>index</code> should follow syntax outlined in <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L171-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.OnePhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np})), I&lt;:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}" href="#WaveguideQED.OnePhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np})), I&lt;:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}"><code>WaveguideQED.OnePhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OnePhotonView(ψ::T,index::I) where {T&lt;:SingleWaveguideKet,I&lt;:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}</code></pre><p>ψ contains only a single waveguide and no waveguide index is needed. <code>index</code> should follow syntax outlined in <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.OnePhotonView-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw}))" href="#WaveguideQED.OnePhotonView-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw}))"><code>WaveguideQED.OnePhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OnePhotonView(ψ::T,WI::Int)  where {T&lt;:MultipleWaveguideKet}</code></pre><p>ψ contains only a multiple waveguides and waveguide index <code>WI</code> is needed. No index of the system is provided and groundstate is assumed (see <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoPhotonTimestepView" href="#WaveguideQED.TwoPhotonTimestepView"><code>WaveguideQED.TwoPhotonTimestepView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TwoPhotonTimestepView{T}</code></pre><p>Structure for viewing slice along same times in twophoton state. Used in <a href="#LinearAlgebra.mul!"><code>mul!</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/view.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoPhotonView" href="#WaveguideQED.TwoPhotonView"><code>WaveguideQED.TwoPhotonView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TwophotonView{T} &lt;: AbstractMatrix{T}</code></pre><p>Structure for viewing twophoton state of the form <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{j}}^\dagger(t&#39;) |\emptyset \rangle$</span> where <span>$i$</span> and <span>$j$</span> are the indeces of the waveguide as matrix. See also <a href="#WaveguideQED.twophoton"><code>twophoton</code></a> and <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a>.</p><p><strong>Examples</strong></p><p>Basic viewing:</p><pre><code class="language- hljs">using LinearAlgebra; #hide
times = 1:1:10;
bw = WaveguideBasis(2,times);
ψ = twophoton(bw,(t1,t2)-&gt;1,norm=false);
ψview = TwoPhotonView(ψ);
ψview == ones((length(times),length(times)))</code></pre><p>Viewing state combined with other basis:</p><pre><code class="language- hljs">using QuantumOptics;
bc = FockBasis(2);
ψcombined = fockstate(bc,2) ⊗ ψ;
ψview = TwoPhotonView(ψcombined,[3,:]);
ψview == ones((length(times),length(times)))</code></pre><p>Viewing twophoton state in waveguide 2 with multiple waveguides</p><pre><code class="language- hljs">bw = WaveguideBasis(2,3,times)
ψ = twophoton(bw,2,(t1,t2)-&gt;1,norm=false);
ψview = TwoPhotonView(ψ,2);
ψview == ones((length(times),length(times)))</code></pre><p>Viewing twophoton state in waveguide 2 with multiple waveguides combined with other basis:</p><pre><code class="language- hljs">ψcombined = fockstate(bc,2) ⊗ ψ;
ψview = TwoPhotonView(ψcombined,2,[3,:]);
ψview == ones((length(times),length(times)))</code></pre><p>Viewing twophotons across waveguide 1 and 2</p><pre><code class="language- hljs">bw = WaveguideBasis(2,3,times)
ψ = twophoton(bw,1,2,(t1,t2)-&gt;1,norm=false);
ψview = TwoPhotonView(ψ,1,2);
ψview == ones((length(times),length(times)))</code></pre><p>Viewing twophotons across waveguide 1 and 2 combined with other basis:</p><pre><code class="language- hljs">ψcombined = fockstate(bc,2) ⊗ ψ;
ψview = TwoPhotonView(ψcombined,1,2,[3,:]);
ψview == ones((length(times),length(times)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L290-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoPhotonView-Tuple{T} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np}))" href="#WaveguideQED.TwoPhotonView-Tuple{T} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np}))"><code>WaveguideQED.TwoPhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TwoPhotonView(ψ::T) where {T &lt;: SingleWaveguideKet}</code></pre><p>State <code>ψ</code> only contains one waveguide and no index provided so groundstate is assumed. See <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L376-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoPhotonView-Union{Tuple{F}, Tuple{I}, Tuple{T}, Tuple{T, F, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I&lt;:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}, F&lt;:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}" href="#WaveguideQED.TwoPhotonView-Union{Tuple{F}, Tuple{I}, Tuple{T}, Tuple{T, F, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I&lt;:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}, F&lt;:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}"><code>WaveguideQED.TwoPhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TwoPhotonView(ψ::T,WI::F,index::I)  where {T&lt;:MultipleWaveguideKet,I&lt;:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}},F&lt;:Union{Vector{Int64},Tuple{Vararg{Int64}}}}</code></pre><p>State <code>ψ</code> contains multiple waveguides.</p><p>Waveguide indeces provided as tuple or vector of length 2, means viewing viewing the state <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{i}}^\dagger(t&#39;) |\emptyset \rangle$</span> with <code>i = WI[1]</code> and <code>j = WI[2]</code>.</p><p>Index should follow syntax highlighted in <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L487-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, Int64, Int64, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I&lt;:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}" href="#WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, Int64, Int64, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I&lt;:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}"><code>WaveguideQED.TwoPhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TwoPhotonView(ψ::T,WI1::Int,WI2::Int,index::I)  where {T&lt;:MultipleWaveguideKet,I&lt;:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}</code></pre><p>State <code>ψ</code> contains multiple waveguides.</p><p>Two waveguide indeces means viewing viewing the state <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{i}}^\dagger(t&#39;) |\emptyset \rangle$</span> with <code>i = WI1</code> and <code>j = WI2</code>.</p><p>Index should follow syntax highlighted in <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L467-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, Int64, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I&lt;:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}" href="#WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, Int64, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I&lt;:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}"><code>WaveguideQED.TwoPhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TwoPhotonView(ψ::T,WI::Int,index::I)  where {T&lt;:MultipleWaveguideKet,I&lt;:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}</code></pre><p>State <code>ψ</code> contains multiple waveguides.</p><p>Only one waveguide index <code>i=WI</code> means viewing the state <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{i}}^\dagger(t&#39;) |\emptyset \rangle$</span>.</p><p>Index should follow syntax highlighted in <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L449-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np})), I&lt;:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}" href="#WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, 1}} where {Np, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, 1}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np})), I&lt;:Union{Vector{Any}, Vector{Int64}, Tuple{Vararg{Union{Colon, Int64}}}}}"><code>WaveguideQED.TwoPhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TwoPhotonView(ψ::T,index::I) where {T &lt;: SingleWaveguideKet,I&lt;:Union{Vector{Any},Vector{Int64},Tuple{Vararg{Union{Int64,Colon}}}}}</code></pre><p>State <code>ψ</code> only contains one waveguide. Index should follow syntax highlighted in <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L389-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I&lt;:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}" href="#WaveguideQED.TwoPhotonView-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw})), I&lt;:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}"><code>WaveguideQED.TwoPhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TwoPhotonView(ψ::T,WI::I) where {T &lt;: MultipleWaveguideKet,I&lt;:Union{Vector{Int64},Tuple{Vararg{Int64}}}}</code></pre><p>State <code>ψ</code> contains multiple waveguides.</p><p>Waveguide indeces provided as tuple or vector of length 2, means viewing viewing the state <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{i}}^\dagger(t&#39;) |\emptyset \rangle$</span> with <code>i = WI[1]</code> and <code>j = WI[2]</code>.</p><p>No index provided so groundstate is assumed. See <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L433-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoPhotonView-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw}))" href="#WaveguideQED.TwoPhotonView-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw}))"><code>WaveguideQED.TwoPhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TwoPhotonView(ψ::T,WI1::Int,WI2::Int) where {T &lt;: MultipleWaveguideKet}</code></pre><p>State <code>ψ</code> contains multiple waveguides.</p><p>Two waveguide indeces means viewing viewing the state <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{i}}^\dagger(t&#39;) |\emptyset \rangle$</span> with <code>i = WI1</code> and <code>j = WI2</code>.</p><p>No index provided so groundstate is assumed. See <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L417-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoPhotonView-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw}))" href="#WaveguideQED.TwoPhotonView-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:(QuantumOpticsBase.Ket{T, Vector{ComplexF64}} where T&lt;:(Union{QuantumInterface.CompositeBasis{Vector{Int64}, T}, WaveguideBasis{Np, Nw}} where {Np, Nw, T&lt;:Tuple{Vararg{Union{WaveguideBasis{Np, Nw}, QuantumInterface.FockBasis, QuantumInterface.NLevelBasis}}}, Np, Nw}))"><code>WaveguideQED.TwoPhotonView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TwoPhotonView(ψ::T,WI::Int) where {T &lt;: MultipleWaveguideKet}</code></pre><p>State <code>ψ</code> contains multiple waveguides and waveguide index <code>WI</code> required. </p><p>Only one waveguide index <code>i=WI</code> means viewing the state <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{i}}^\dagger(t&#39;) |\emptyset \rangle$</span>.</p><p>No index provided so groundstate is assumed. See <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L401-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoWaveguideTimestepView" href="#WaveguideQED.TwoWaveguideTimestepView"><code>WaveguideQED.TwoWaveguideTimestepView</code></a> — <span class="docstring-category">Type</span></header><section><div><p>TwoWaveguideTimestepView{T} &lt;:AbstractVector{T}</p><p>Structure for viewing slice along same times in twophoton states in two waveguides. Used in <a href="#LinearAlgebra.mul!"><code>mul!</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/view.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.TwoWaveguideView" href="#WaveguideQED.TwoWaveguideView"><code>WaveguideQED.TwoWaveguideView</code></a> — <span class="docstring-category">Type</span></header><section><div><p>TwoWaveguideView{T} &lt;: AbstractMatrix{T}</p><p>Structure for viewing state with one photon in waveguide i and j. Returned from <a href="#WaveguideQED.TwoPhotonView"><code>TwoPhotonView</code></a>. See also <a href="#WaveguideQED.TwoPhotonView"><code>TwoPhotonView</code></a>, <a href="#WaveguideQED.twophoton"><code>twophoton</code></a>, and <a href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>view_waveguide</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L500-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.WaveguideBasis" href="#WaveguideQED.WaveguideBasis"><code>WaveguideQED.WaveguideBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WaveguideBasis(Np,Nw, times)
WaveguideBasis(Np, times)</code></pre><p>Basis for time binned Waveguide where <code>Np</code> is the number of photons in the waveguide and <code>Nw</code> the number of waveguides (default is 1). Currently number of photons is restricted to either 1 or 2. Times is timeinterval over which the photon state should be binned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.WaveguideCreate" href="#WaveguideQED.WaveguideCreate"><code>WaveguideQED.WaveguideCreate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WaveguideCreate{B1,B2,N,idx} &lt;: WaveguideOperator{B1,B2}</code></pre><p>Operator structure for dispatching creation operation on Waveguide state. Np is used to dispatch one or two photon routine and idx denotes the index of the waveguide the operator is acting on. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.WaveguideDestroy" href="#WaveguideQED.WaveguideDestroy"><code>WaveguideQED.WaveguideDestroy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WaveguideDestroy{B1,B2,Np,idx} &lt;: WaveguideOperator{B1,B2}</code></pre><p>Operator structure for dispatching annihilation operation on Waveguide state. Np is used to dispatch one or two photon routine and idx denotes the index of the waveguide the operator is acting on. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.WaveguideOperator" href="#WaveguideQED.WaveguideOperator"><code>WaveguideQED.WaveguideOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract class for WaveguideOperators. Used to dispatch special mul! function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.WaveguideTransform" href="#WaveguideQED.WaveguideTransform"><code>WaveguideQED.WaveguideTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WaveguideTransform{B1,B2,Np,idx} &lt;: WaveguideOperator{B1,B2}</code></pre><p>Operator structure for transforming an output state <span>$\ket{\psi}_{\mathrm{out}} = \mathbf{C} \ket{\tilde{\psi}}_{\mathrm{out}}$</span> Np is used to dispatch one or two photon routine and idx denotes the index of the waveguide the operator is acting on. See also <a href="#WaveguideQED.effective_hamiltonian-Union{Tuple{Nw}, Tuple{Np}, Tuple{WaveguideBasis{Np, Nw}, Any, Any, Any}} where {Np, Nw}"><code>effective_hamiltonian</code></a>.</p><p>Examples:</p><pre><code class="nohighlight hljs">times = 0:0.1:10
bw = WaveguideBasis(1,2,times)
C = 1/sqrt(2)*[1.0 -im;-im 1]
C_transform = WaveguideTransform(bw,C)
psi_tilde = ket(bw)
psi = C_transform*psi_tilde</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/InputOutput.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.dagger-Union{Tuple{WaveguideCreate{B, B, Np, idx}}, Tuple{idx}, Tuple{Np}, Tuple{B}} where {B, Np, idx}" href="#QuantumInterface.dagger-Union{Tuple{WaveguideCreate{B, B, Np, idx}}, Tuple{idx}, Tuple{Np}, Tuple{B}} where {B, Np, idx}"><code>QuantumInterface.dagger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dagger(op::WaveguideCreate)
dagger(op::WaveguideCreate)</code></pre><p>Dagger opration on Waveguide operator. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L113-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.identityoperator-Tuple{CavityWaveguideOperator}" href="#QuantumInterface.identityoperator-Tuple{CavityWaveguideOperator}"><code>QuantumInterface.identityoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">identityoperator(a::CavityWaveguideOperator)</code></pre><p>Return identityoperator(a.basis_l).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/CavityWaveguideOperator.jl#L234-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.identityoperator-Tuple{WaveguideOperator}" href="#QuantumInterface.identityoperator-Tuple{WaveguideOperator}"><code>QuantumInterface.identityoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">identityoperator(a::WaveguideOperator)</code></pre><p>Return identityoperator(a.basis_l).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.tensor-Tuple{QuantumInterface.AbstractOperator, CavityWaveguideAbsorption}" href="#QuantumInterface.tensor-Tuple{QuantumInterface.AbstractOperator, CavityWaveguideAbsorption}"><code>QuantumInterface.tensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tensor(a::AbstractOperator,b::CavityWaveguideAbsorption)
tensor(a::CavityWaveguideAbsorption,b::AbstractOperator)
tensor(a::AbstractOperator,b::CavityWaveguideEmission)
tensor(a::CavityWaveguideEmission,b::AbstractOperator)</code></pre><p>Methods for tensorproducts between QuantumOptics.jl operators and <a href="#WaveguideQED.CavityWaveguideOperator"><code>CavityWaveguideOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/CavityWaveguideOperator.jl#L247-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.create-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np" href="#QuantumOpticsBase.create-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np"><code>QuantumOpticsBase.create</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create(basis::WaveguideBasis{Np,1}) where {Np}
create(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}</code></pre><p>Creation operator <span>$w^\dagger$</span> for <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> <span>$w_i(t_k)^\dagger | \emptyset \rangle = | 1_k \emptyset \rangle_i$</span> with cutoff (maximum number of photons Np) where <code>i</code> is the index of the waveguide. <span>$t_k$</span> is determined by the timeindex property of the operator which can be changed by <a href="#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:WaveguideOperator"><code>set_waveguidetimeindex!(a::WaveguideOperator,k::Int)</code></a> </p><p><strong>Arguments</strong></p><ul><li>basis of type WaveguideBasis, defines cutoff photon number <code>Np</code> and number of waveguides <code>Nw</code></li><li><code>i</code> determines which waveguide the operator acts on and should be <code>i ≤ Nw</code>. If <code>Nw=1</code> then <code>i=1</code> is assumed (there is only one waveguide).</li></ul><p><strong>Returns</strong></p><p><a href="#WaveguideQED.WaveguideCreate"><code>WaveguideCreate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L87-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.destroy-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np" href="#QuantumOpticsBase.destroy-Union{Tuple{WaveguideBasis{Np, 1}}, Tuple{Np}} where Np"><code>QuantumOpticsBase.destroy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">destroy(basis::WaveguideBasis{Np,1}) where {Np}
destroy(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}</code></pre><p>Annihilation operator <span>$w$</span> for <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> <span>$w_i(t_k) | 1_j \emptyset \rangle_i = \delta_{k,j} | \emptyset \rangle$</span> with cutoff (maximum number of photons Np) where <code>i</code> is the index of the waveguide. <span>$t_k$</span> is determined by the timeindex property of the operator which can be changed by <a href="#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:WaveguideOperator"><code>set_waveguidetimeindex!(a::WaveguideOperator,k::Int)</code></a> </p><p><strong>Arguments</strong></p><ul><li>basis of type WaveguideBasis, defines cutoff photon number <code>Np</code> and number of waveguides <code>Nw</code></li><li><code>i</code> determines which waveguide the operator acts on and should be <code>i ≤ Nw</code>. If <code>Nw=1</code> then <code>i=1</code> is assumed (there is only one waveguide).</li></ul><p><strong>Returns</strong></p><p><a href="#WaveguideQED.WaveguideDestroy"><code>WaveguideDestroy</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L63-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.absorption-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}" href="#WaveguideQED.absorption-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}"><code>WaveguideQED.absorption</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absorption(b1::WaveguideBasis{T},b2::FockBasis) where T
absorption(b1::FockBasis,b2::WaveguideBasis{T}) where T</code></pre><p>Create <a href="#WaveguideQED.CavityWaveguideAbsorption"><code>CavityWaveguideAbsorption</code></a> that applies <code>create(b::FockBasis)</code> on <code>FockBasis</code> and destroy(b::WaveguideBasis{T}) on <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis{T}</code></a>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/CavityWaveguideOperator.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.detect_double_click-Union{Tuple{B}, Tuple{Any, Detector{B}, Detector{B}, Any}} where B" href="#WaveguideQED.detect_double_click-Union{Tuple{B}, Tuple{Any, Detector{B}, Detector{B}, Any}} where B"><code>WaveguideQED.detect_double_click</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">detect_double_click(ψ,detector1,detector2,projection)
detect_double_click(ψ,detector1,detector2)</code></pre><p>Calculate probability of observing <code>projection</code> after beamsplitter operation and two subsequent detection events defined in <code>detector1</code> and <code>detector2</code> on the state <code>ψ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ</code> can be either <a href="#WaveguideQED.LazyTensorKet"><code>LazyTensorKet</code></a> or <a href="#WaveguideQED.LazySumKet"><code>LazySumKet</code></a> and is the state on which the beamsplitter and detection is applied</li><li><code>detector1</code> defines the first beamsplitter and subsequent detection operation. See <a href="#WaveguideQED.Detector"><code>Detector</code></a> for more details on how to define.</li><li><code>detector2</code> defines the second beamsplitter and subsequent detection operation. See <a href="#WaveguideQED.Detector"><code>Detector</code></a> for more details on how to define.</li><li><code>projection</code> if given is a <a href="#WaveguideQED.LazyTensorKet"><code>LazyTensorKet</code></a> or <a href="#WaveguideQED.LazySumKet"><code>LazySumKet</code></a> which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using <a href="#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}"><code>get_all_projectors</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>projection</code> is given: Returns probability of having <code>detector1</code> and <code>detector2</code> click and being in state defined by <code>projection</code></li><li>If <code>projection</code> is not given: Returns the total probability of having <code>detector1</code> and <code>detector2</code> click by applying all possibile projections with zerophotons in the waveguide using <a href="#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}"><code>get_all_projectors</code></a>.</li></ul><p>See <a href="https://mabuni1998.github.io/WaveguideQED/dev/detection_example/">Beamsplitter</a> for an example on how to use. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/detection.jl#L284-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.detect_single_click-Tuple{Any, Detector, Any}" href="#WaveguideQED.detect_single_click-Tuple{Any, Detector, Any}"><code>WaveguideQED.detect_single_click</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">detect_single_click(ψ,detector::Detector,projection)
detect_single_click(ψ,detector::Detector)</code></pre><p>Calculate probability of observing <code>projection</code> after beamsplitter operation and subsequent detection event defined in <code>detector</code> on the state <code>ψ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ψ</code> can be either <a href="#WaveguideQED.LazyTensorKet"><code>LazyTensorKet</code></a> or <a href="#WaveguideQED.LazySumKet"><code>LazySumKet</code></a> and is the state on which the beamsplitter and detection is applied</li><li><code>detector</code> defines the beamsplitter and subsequent detection operation. See <a href="#WaveguideQED.Detector"><code>Detector</code></a> for more details on how to define.</li><li><code>projection</code> if given is a <a href="#WaveguideQED.LazyTensorKet"><code>LazyTensorKet</code></a> or <a href="#WaveguideQED.LazySumKet"><code>LazySumKet</code></a> which projects onto the state after the measurement.  If no projection is given, instead the total probability of having the detector click is given by applying all possible combinations of projections using <a href="#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}"><code>get_all_projectors</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>projection</code> is given returns probability of having detector click and being in state defined by <code>projection</code></li><li>If <code>projection</code> is not given returns the total probability of having a the detector click (only a single click, for double clicks use <a href="#WaveguideQED.detect_double_click-Union{Tuple{B}, Tuple{Any, Detector{B}, Detector{B}, Any}} where B"><code>detect_double_click</code></a>) by applying all possibile projections with zerophotons in the waveguide using <a href="#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}"><code>get_all_projectors</code></a>.</li></ul><p>See <a href="https://mabuni1998.github.io/WaveguideQED/dev/detection_example/">Beamsplitter</a> for an example on how to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/detection.jl#L149-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.effective_hamiltonian-Union{Tuple{Nw}, Tuple{Np}, Tuple{WaveguideBasis{Np, Nw}, Any, Any, Any}} where {Np, Nw}" href="#WaveguideQED.effective_hamiltonian-Union{Tuple{Nw}, Tuple{Np}, Tuple{WaveguideBasis{Np, Nw}, Any, Any, Any}} where {Np, Nw}"><code>WaveguideQED.effective_hamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">effective_hamiltonian(bw::WaveguideBasis{Np,Nw},bs,C,G) where {Np,Nw}</code></pre><p>Return the effective Hamiltonian for a waveguide system with basis <code>bw</code> coupled to a local emitter/cavity with the basis <code>bc</code>. <code>C</code> and <code>G</code> here determine the input output relations of the coupling such that: <span>$\frac{d}{d t} a=-i\left[a, H_{\mathrm{c}}\right]-\Sigma a+\mathbf{k}^T \mathbf{W}_{\mathrm{in}}$</span>, and <span>$\mathbf{W}_{\text {out }}(t)=\mathbf{C} \mathbf{W}_{\mathrm{in}}(t)+a(t)\mathbf{d}$</span>.  Here <span>$\Tilde{\mathbf{d}} =  \Tilde{\mathbf{k}} = -i \left(\left(\mathbf{I}+\frac{i}{2} \mathbf{V}\right)^{-1} \right) \mathbf{\Gamma}$</span>, where <span>$\mathbf{\Gamma}$</span> is determined by the vector <code>G</code> with a length equal to the number of waveguide in <code>bw</code>. <span>$\mathbf{C}$</span> is here given by <code>C</code> which is of dimensions (nw,nw) with nw being the number of waveguides in <code>bw</code>.</p><p>The resulting state <span>$\ket{\tilde{\psi}}_{\mathrm{out}}$</span> from simulating with this Hamiltonian needs to be transformed using <a href="#WaveguideQED.WaveguideTransform"><code>WaveguideTransform</code></a> such that <span>$\ket{\psi}_{\mathrm{out}} = \mathbf{C} \ket{\tilde{\psi}}_{\mathrm{out}}$</span> to get the correct input-output relations.</p><p>Examples:</p><pre><code class="nohighlight hljs">times = 0:0.1:10
dt = times[2] - times[1]

bw = WaveguideBasis(1,2,times)
be = FockBasis(1)


C = [0 -1.0im; -1.0im 0]
γ=1
G = [sqrt(γ/dt),sqrt(γ/dt)]

H = effective_hamiltonian(bw,be,C,G)

ξfun(t1,σ,t0) = sqrt(2/σ)* (log(2)/pi)^(1/4)*exp(-2*log(2)*(t1-t0)^2/σ^2)

ψ_in = onephoton(bw,1,ξfun,1,5) ⊗ fockstate(be,0)
ψ_out_tilde = waveguide_evolution(times,ψ_in,H)


C_transform = WaveguideTransform(bw,C) ⊗ identityoperator(be)
ψ_out = C_transform*ψ_out_tilde</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/InputOutput.jl#L92-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.emission-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}" href="#WaveguideQED.emission-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, QuantumInterface.FockBasis, Any}} where {T, Nw}"><code>WaveguideQED.emission</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">emission(b1::WaveguideBasis{T},b2::FockBasis) where T
emission(b1::FockBasis,b2::WaveguideBasis{T}) where T</code></pre><p>Create <a href="#WaveguideQED.CavityWaveguideEmission"><code>CavityWaveguideEmission</code></a> that applies <code>destroy(b::FockBasis)</code> on <code>FockBasis</code> and create(b::WaveguideBasis{T}) on <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis{T}</code></a>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/CavityWaveguideOperator.jl#L181-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.fast_unitary-Tuple{Any, Any, Any}" href="#WaveguideQED.fast_unitary-Tuple{Any, Any, Any}"><code>WaveguideQED.fast_unitary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fast_unitary(times_eval,psi,H;order=2,fout=nothing)</code></pre><p>See documentation for <a href="#WaveguideQED.waveguide_evolution-Tuple{Any, Any, Any}"><code>waveguide_evolution</code></a> on how to define <code>fout</code>. J should be a list of collapse operators following documentation of <a href="https://docs.qojulia.org/api/#QuantumOptics.timeevolution.mcwf_dynamic"><code>timeevolution.mcwf_dynamic</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/solver.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.fftket-Tuple{QuantumOpticsBase.Ket, Any}" href="#WaveguideQED.fftket-Tuple{QuantumOpticsBase.Ket, Any}"><code>WaveguideQED.fftket</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fftket(psi::Ket,idx)</code></pre><p>Return the FFT <span>$\xi(\omega)$</span> of a onephoton wavefunction <span>$\xi(t)$</span>. Idx determines which waveguide.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/InputOutput.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}" href="#WaveguideQED.get_all_projectors-Tuple{QuantumInterface.CompositeBasis}"><code>WaveguideQED.get_all_projectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_all_projectors(b)</code></pre><p>Returns all combinations of possible states with zerophotons in the waveguide. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/detection.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_dt-Tuple{WaveguideBasis}" href="#WaveguideQED.get_dt-Tuple{WaveguideBasis}"><code>WaveguideQED.get_dt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_dt(basis::WaveguideBasis)
get_dt(basis::Basis)
get_dt(basis::CompositeBasis)</code></pre><p>Return nsteps of <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> given either a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> or a <code>CompositeBasis</code> containing a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L782-L788">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_nsteps-Tuple{WaveguideBasis}" href="#WaveguideQED.get_nsteps-Tuple{WaveguideBasis}"><code>WaveguideQED.get_nsteps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_nsteps(basis::WaveguideBasis)
get_nsteps(basis::Basis)
get_nsteps(basis::CompositeBasis)</code></pre><p>Return nsteps of <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> given either a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> or a <code>CompositeBasis</code> containing a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L761-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_number_of_waveguides-Union{Tuple{WaveguideBasis{Np, Nw}}, Tuple{Nw}, Tuple{Np}} where {Np, Nw}" href="#WaveguideQED.get_number_of_waveguides-Union{Tuple{WaveguideBasis{Np, Nw}}, Tuple{Nw}, Tuple{Np}} where {Np, Nw}"><code>WaveguideQED.get_number_of_waveguides</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_number_of_waveguides(basis::WaveguideBasis)
get_number_of_waveguides(basis::Basis)
get_number_of_waveguides(basis::CompositeBasis)</code></pre><p>Return number of waveguides Nw of <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis{Np,Nw}</code></a> given either a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis{Np,Nw}</code></a> or a <code>CompositeBasis</code> containing a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis{Np,Nw}</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L803-L809">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_waveguide_basis-Tuple{QuantumInterface.CompositeBasis}" href="#WaveguideQED.get_waveguide_basis-Tuple{QuantumInterface.CompositeBasis}"><code>WaveguideQED.get_waveguide_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_waveguide_basis(basis::CompositeBasis)</code></pre><p>Returns <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> from <code>CompositeBasis.bases</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L824-L829">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_waveguide_location-Tuple{WaveguideBasis}" href="#WaveguideQED.get_waveguide_location-Tuple{WaveguideBasis}"><code>WaveguideQED.get_waveguide_location</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_waveguide_location(basis::WaveguideBasis)
get_waveguide_location(basis::CompositeBasis)</code></pre><p>Return index of <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> location in Hilbert space of basis b. <code>Btotal = waveguidebasis ⊗ otherbasis</code> where waveguidebasis is a <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> and <code>otherbasis</code> some other basis then <code>get_waveguide_location(Btotal)</code> returns 1.  While <code>Btotal = otherbasis ⊗ waveguidebasis</code> with <code>get_waveguide_location(Btotal)</code> returns 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L745-L752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_waveguide_operators-Tuple{QuantumOpticsBase.LazySum}" href="#WaveguideQED.get_waveguide_operators-Tuple{QuantumOpticsBase.LazySum}"><code>WaveguideQED.get_waveguide_operators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_waveguide_operators(basis::LazySum)
get_waveguide_operators(basis::LazyProduct)
get_waveguide_operators(basis::LazyTensor)
get_waveguide_operators(basis::Tuple)
get_waveguide_operators(basis::Array)
get_waveguide_operators(basis::WaveguideOperator)</code></pre><p>Returns all <a href="#WaveguideQED.WaveguideOperator"><code>WaveguideOperator</code></a> in LazyOperator or from a list of operators. If no <a href="#WaveguideQED.WaveguideOperator"><code>WaveguideOperator</code></a> is found, and empty array is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L489-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.get_waveguidetimeindex-Tuple{Any}" href="#WaveguideQED.get_waveguidetimeindex-Tuple{Any}"><code>WaveguideQED.get_waveguidetimeindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_waveguidetimeindex(op)</code></pre><p>Return timeindex of operator or list of operators containing <a href="#WaveguideQED.WaveguideOperator"><code>WaveguideOperator</code></a> and assert that all timeindeces are the same. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L532-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.onephoton" href="#WaveguideQED.onephoton"><code>WaveguideQED.onephoton</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create a onephoton wavepacket in waveguide of the form <span>$W^\dagger(\xi) |0 \rangle = \int_{t_0}^{t_{end}} dt  \xi(t) w_{\mathrm{i}}^\dagger(t) |\emptyset \rangle = \sum_{k}$</span> where <span>$i$</span> is the index of the waveguide and return it as a <code>Ket</code>. See also <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> and <a href="#WaveguideQED.OnePhotonView"><code>OnePhotonView</code></a> for how to view the state. </p><p><strong>Examples</strong></p><pre><code class="language- hljs">dt = 1
times = 1:dt:10;
bw = WaveguideBasis(1,times);
ψ = onephoton(bw,x-&gt;dt,norm=false);
OnePhotonView(ψ) == ones(length(times))</code></pre><pre><code class="language- hljs">vec = collect(1:1:10);
ψ = onephoton(bw,vec);
OnePhotonView(ψ) == vec</code></pre><pre><code class="language- hljs">bw = WaveguideBasis(1,3,times);
ψ = onephoton(bw,2,x-&gt;dt);
OnePhotonView(ψ,2) == ones(length(times))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L187-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.onephoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, AbstractArray}} where {T, Nw}" href="#WaveguideQED.onephoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, AbstractArray}} where {T, Nw}"><code>WaveguideQED.onephoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onephoton(b::WaveguideBasis{T,Nw},i,ξvec;norm=true) where {T,Nw}</code></pre><ul><li>Since <code>b</code> contains a <code>Nw</code> waveguides, the index of the waveguide needed.</li><li><code>i</code> is the index of the waveguide at which the onephoton wavepacket is created in</li><li><code>ξ</code> should be <code>AbstractArray</code> with length(ξ) == b.nsteps</li><li><code>norm::Bool=true</code>: If true normalize the resulting wavepacket.    </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L266-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.onephoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Function, Vararg{Any}}} where {T, Nw}" href="#WaveguideQED.onephoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Function, Vararg{Any}}} where {T, Nw}"><code>WaveguideQED.onephoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onephoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Function,args...; norm=true) where {T,Nw}</code></pre><ul><li>Since <code>b</code> contains <code>Nw</code> waveguides, the index of the waveguide needed.</li><li><code>i</code> is the index of the waveguide at which the onephoton wavepacket is created in</li><li><code>ξ</code> should be broadcastable as ξ.(times,args...), where <code>times  = 0:b.dt:(b.nsteps-1)*b.dt</code> (the times used to define the waveguidebasis)</li><li><code>args...</code>: additional arguments to be passed to ξ if it is a function.</li><li><code>norm::Bool=true</code>: If true normalize the resulting wavepacket.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L247-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.onephoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, AbstractArray}} where T" href="#WaveguideQED.onephoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, AbstractArray}} where T"><code>WaveguideQED.onephoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onephoton(b::WaveguideBasis{T,1},ξ::AbstractArray;norm=true) where {T}</code></pre><ul><li>Since <code>b</code> only contains a single waveguide, the index of the waveguide is not needed. </li><li><code>ξ</code> should be <code>AbstractArray</code> with length(ξ) == b.nsteps </li><li><code>norm::Bool=true</code>: If true normalize the resulting wavepacket.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L230-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.onephoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Vararg{Any}}} where T" href="#WaveguideQED.onephoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Vararg{Any}}} where T"><code>WaveguideQED.onephoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onephoton(b::WaveguideBasis{T,1},ξ::Function,args...,norm=True) where {T}</code></pre><ul><li>Since <code>b</code> only contains a single waveguide, the index of the waveguide is not needed. </li><li><code>ξ</code> should be broadcastable as ξ.(times,args...), where <code>times  = 0:b.dt:(b.nsteps-1)*b.dt</code> (the times used to define the waveguidebasis)</li><li><code>args...</code>: additional arguments to be passed to ξ if it is a function.</li><li><code>norm::Bool=true</code>: If true normalize the resulting wavepacket.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L212-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.plot_twophoton!-Tuple{Any, TwoPhotonView, Any}" href="#WaveguideQED.plot_twophoton!-Tuple{Any, TwoPhotonView, Any}"><code>WaveguideQED.plot_twophoton!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_twophoton!(ax,twophotonstate::TwophotonView,times;kwargs...)
plot_twophoton!(ax,twophotonstate::TwoWaveguideView,times;kwargs...)
plot_twophoton!(ax,state::Ket,times;kwargs...)
plot_twophoton!(ax,twophotonstate,times;kwargs...)</code></pre><p>Plots the twophoton state in the given ax. </p><p><strong>Arguments</strong></p><ul><li>ax of type PyObject &lt;AxesSubplot: &gt; from <code>PyPlot</code></li><li>State to be plotted twophotonstate or state. If state is a <code>Ket</code> <a href="#WaveguideQED.TwoPhotonView"><code>TwoPhotonView</code></a> is called to extract twophotonstate. Otherwise twophotonstate should be AbstractArray of dimensions (length(times),length(times)).</li></ul><p>#Return ax.contour object with the plotted state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/plotting.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:WaveguideOperator" href="#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:WaveguideOperator"><code>WaveguideQED.set_waveguidetimeindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_waveguidetimeindex!(op,index)</code></pre><p>Set timeindex of all <a href="#WaveguideQED.WaveguideOperator"><code>WaveguideOperator</code></a> in operator or list of operators to index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L550-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.twophoton" href="#WaveguideQED.twophoton"><code>WaveguideQED.twophoton</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create a twophoton wavepacket of the form <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{j}}^\dagger(t&#39;) |\emptyset \rangle$</span> where <span>$i$</span> and <span>$j$</span> are the indeces of the waveguide and return it as a <code>Ket</code>.</p><p>See also <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> and <a href="#WaveguideQED.TwoPhotonView"><code>TwoPhotonView</code></a> for how to view the state. </p><p>#Examples  Creating twophoton state with only one waveguide (using a function):</p><pre><code class="language- hljs">using LinearAlgebra; #hide
times = 1:1:10;
bw = WaveguideBasis(2,times);
ψ = twophoton(bw,(t1,t2)-&gt;1,norm=false);
ψview = TwoPhotonView(ψ);
ψview == ones((length(times),length(times)))

ψ = twophoton(bw,(t1,t2,arg1)-&gt;arg1,123,norm=false);
ψview = TwoPhotonView(ψ);
ψview == 123*ones((length(times),length(times)))
</code></pre><p>Creating twophoton state with only one waveguide (using a matrix):</p><pre><code class="language- hljs">ψ = twophoton(bw,ones((length(times),length(times))),norm=false);
ψview = TwoPhotonView(ψ);
ψview == ones((length(times),length(times)))</code></pre><p>Creating twophoton state in waveguide 2 with multiple waveguides</p><pre><code class="language- hljs">bw = WaveguideBasis(2,3,times)
ψ = twophoton(bw,2,(t1,t2)-&gt;1,norm=false);</code></pre><p>Creating twophoton state across waveguide 1 and 2</p><pre><code class="language- hljs">bw = WaveguideBasis(2,3,times)
ψ = twophoton(bw,1,2,(t1,t2)-&gt;1,norm=false);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L529-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.twophoton-Union{Tuple{I}, Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, I, Function, Any, Vararg{Any}}} where {T, Nw, I&lt;:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}" href="#WaveguideQED.twophoton-Union{Tuple{I}, Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, I, Function, Any, Vararg{Any}}} where {T, Nw, I&lt;:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}"><code>WaveguideQED.twophoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">twophoton(b::WaveguideBasis{T,Nw},idx::I,ξ::Function,times,args...;norm=true) where {T,Nw,I&lt;:Union{Vector{Int64},Tuple{Vararg{Int64}}}} = twophoton(b,idx[1],idx[2],ξ,times,args...,norm=norm)</code></pre><p><strong>Arguments</strong></p><ul><li><code>b::WaveguideBasis{T,Nw}</code> contains multiple waveguides and index i is need.</li><li><code>I[1]</code> denotes the index <span>$i$</span> of the waveguide in the twophoton state: <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{j}}^\dagger(t&#39;) |\emptyset \rangle$</span>.</li><li><code>I[2]</code> denotes the index <span>$j$</span> of the waveguide in the twophoton state: <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{j}}^\dagger(t&#39;) |\emptyset \rangle$</span>.</li><li>ξ given as a function should follow  <code>ξ(times[l],times[m],args...)</code>.</li><li><code>times</code>: A vector or range of length(times) = b.nsteps.</li><li><code>args...</code>: additional arguments to be passed to ξ.</li><li><code>norm::Bool=true</code>: normalize the resulting wavepacket.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L731-L742">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.twophoton-Union{Tuple{I}, Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, I, Matrix}} where {T, Nw, I&lt;:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}" href="#WaveguideQED.twophoton-Union{Tuple{I}, Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, I, Matrix}} where {T, Nw, I&lt;:Union{Tuple{Vararg{Int64}}, Vector{Int64}}}"><code>WaveguideQED.twophoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">twophoton(b::WaveguideBasis{T,Nw},idx::I,ξ::Matrix;norm=true) where {T,Nw,I&lt;:Union{Vector{Int64},Tuple{Vararg{Int64}}}}</code></pre><p><strong>Arguments</strong></p><ul><li><code>b::WaveguideBasis{T,Nw}</code> contains multiple waveguides and index i is need.</li><li><code>I[1]</code> denotes the index <span>$i$</span> of the waveguide in the twophoton state: <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{j}}^\dagger(t&#39;) |\emptyset \rangle$</span>.</li><li><code>I[2]</code> denotes the index <span>$j$</span> of the waveguide in the twophoton state: <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{j}}^\dagger(t&#39;) |\emptyset \rangle$</span>.</li><li>ξ given as a matrix of dimension <code>(b.nsteps, b.nsteps)</code>.</li><li><code>norm::Bool=true</code>: normalize the resulting wavepacket.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L719-L727">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Function, Vararg{Any}}} where {T, Nw}" href="#WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Function, Vararg{Any}}} where {T, Nw}"><code>WaveguideQED.twophoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">twophoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Function,args...;norm=true) where {T,Nw}</code></pre><p><strong>Arguments</strong></p><ul><li><code>b::WaveguideBasis{T,Nw}</code> contains multiple waveguides and index i is need.</li><li><code>i</code> denotes the index of the waveguide in the twophoton state: <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{i}}^\dagger(t&#39;) |\emptyset \rangle$</span>.</li><li>ξ given as a function should follow  <code>ξ(t1,t2,args...)</code> where <code>t1</code> and <code>t2</code> are the input times.</li><li><code>args...</code>: additional arguments to be passed to ξ.</li><li><code>norm::Bool=true</code>: normalize the resulting wavepacket.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L619-L628">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Int64, Function, Vararg{Any}}} where {T, Nw}" href="#WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Int64, Function, Vararg{Any}}} where {T, Nw}"><code>WaveguideQED.twophoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">twophoton(b::WaveguideBasis{T,Nw},i::Int,j::Int,ξ::Function,args...;norm=true) where {T,Nw}</code></pre><p><strong>Arguments</strong></p><ul><li><code>b::WaveguideBasis{T,Nw}</code> contains multiple waveguides and index i is need.</li><li><code>i</code> denotes the index of the waveguide in the twophoton state: <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{j}}^\dagger(t&#39;) |\emptyset \rangle$</span>.</li><li><code>j</code> denotes the index of the waveguide in the twophoton state: <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{j}}^\dagger(t&#39;) |\emptyset \rangle$</span>.</li><li>ξ given as a function should follow  <code>ξ(t1,t2,args...)</code> where <code>t1</code> and <code>t2</code> are the input times.</li><li><code>args...</code>: additional arguments to be passed to ξ.</li><li><code>norm::Bool=true</code>: normalize the resulting wavepacket.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L668-L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Int64, Matrix}} where {T, Nw}" href="#WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Int64, Matrix}} where {T, Nw}"><code>WaveguideQED.twophoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">twophoton(b::WaveguideBasis{T,Nw},i::Int,j::Int,ξ::Matrix;norm=true) where {T,Nw}</code></pre><p><strong>Arguments</strong></p><ul><li><code>b::WaveguideBasis{T,Nw}</code> contains multiple waveguides and index i is need.</li><li><code>i</code> denotes the index of the waveguide in the twophoton state: <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{j}}^\dagger(t&#39;) |\emptyset \rangle$</span>.</li><li><code>j</code> denotes the index of the waveguide in the twophoton state: <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{j}}^\dagger(t&#39;) |\emptyset \rangle$</span>.</li><li>ξ given as a matrix of dimension <code>(b.nsteps, b.nsteps)</code>.</li><li><code>norm::Bool=true</code>: normalize the resulting wavepacket.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L694-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Matrix}} where {T, Nw}" href="#WaveguideQED.twophoton-Union{Tuple{Nw}, Tuple{T}, Tuple{WaveguideBasis{T, Nw}, Int64, Matrix}} where {T, Nw}"><code>WaveguideQED.twophoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">twophoton(b::WaveguideBasis{T,Nw},i::Int,ξ::Matrix;norm=true) where {T,Nw}</code></pre><p><strong>Arguments</strong></p><ul><li><code>b::WaveguideBasis{T,Nw}</code> contains multiple waveguides and index i is need.</li><li><code>i</code> denotes the index of the waveguide in the twophoton state: <span>$\int_{t_0}^{t_{end}} dt&#39; \int_{t_0}^{t_{end}} dt  \xi(t,t&#39;) w_{\mathrm{i}}^\dagger(t)w_{\mathrm{i}}^\dagger(t&#39;) |\emptyset \rangle$</span>.</li><li>ξ given as a matrix of dimension <code>(b.nsteps, b.nsteps)</code>.</li><li><code>norm::Bool=true</code>: normalize the resulting wavepacket.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L644-L652">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.twophoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Vararg{Any}}} where T" href="#WaveguideQED.twophoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Function, Vararg{Any}}} where T"><code>WaveguideQED.twophoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">twophoton(b::WaveguideBasis{T,1},ξ::Function,args...,norm=True) where {T}</code></pre><p><strong>Arguments</strong></p><ul><li><code>b::WaveguideBasis{T,Nw}</code> contains only one waveguide and no index needed.</li><li>ξ given as a function should follow  <code>ξ(t1,t2,args...)</code>,  where <code>t1</code> and <code>t2</code> are the input times.</li><li><code>args...</code>: additional arguments to be passed to ξ if it is a function.</li><li><code>norm::Bool=true</code>: normalize the resulting wavepacket.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L571-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.twophoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Matrix}} where T" href="#WaveguideQED.twophoton-Union{Tuple{T}, Tuple{WaveguideBasis{T, 1}, Matrix}} where T"><code>WaveguideQED.twophoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">twophoton(b::WaveguideBasis{T,1},ξ::Matrix;norm=true) where {T}</code></pre><p><strong>Arguments</strong></p><ul><li><code>b::WaveguideBasis{T,Nw}</code> contains only one waveguide and no index needed.</li><li>ξ given as a matrix of dimension <code>(b.nsteps, b.nsteps)</code>.</li><li><code>norm::Bool=true</code>: normalize the resulting wavepacket.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L596-L603">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}" href="#WaveguideQED.view_waveguide-Tuple{QuantumOpticsBase.Ket}"><code>WaveguideQED.view_waveguide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view_waveguide(ψ::ket)
view_waveguide(ψ::ket,index)</code></pre><p>View the Waveguide state given a state ψ containing a WaveguideBasis by returning <code>view(reshape(ψ.data,Tuple(ψ.basis.shape)),index...)</code>. If no index is provided the ground state is returned. The index provided should be of the form <code>[:,i,j]</code> where <code>(:)</code> is at the location of the WaveguideBasis and i and j are indeces of other basises. See example: </p><pre><code class="language- hljs">using QuantumOptics;
times=0:1:10;
bw = WaveguideBasis(1,times);
bc = FockBasis(2);
ψ_waveguide = Ket(bw,ones(length(times)));
ψ_total = ψ_waveguide ⊗ fockstate(bc,0) ⊗ fockstate(bc,0);
ψ_view = view_waveguide(ψ_total);
ψ_view_index = view_waveguide(ψ_total,[:,1,1]);
ψ_view==ψ_view_index</code></pre><pre><code class="language- hljs">ψ_total = ψ_waveguide ⊗ fockstate(bc,2) ⊗ fockstate(bc,1);
view_waveguide(ψ_total,[:,3,2]) == ones(length(times))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L42-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.waveguide_evolution-Tuple{Any, Any, Any}" href="#WaveguideQED.waveguide_evolution-Tuple{Any, Any, Any}"><code>WaveguideQED.waveguide_evolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">waveguide_evolution(tspan, psi0, H; fout)</code></pre><p>Integrate time-dependent Schroedinger equation to evolve states or compute propagators.</p><p><strong>Arguments</strong></p><ul><li><code>tspan</code>: Vector specifying the points of time for which output should be displayed.</li><li><code>psi0</code>: Initial state vector can only be a ket.</li><li><code>H</code>: Operator containing a <a href="#WaveguideQED.WaveguideOperator"><code>WaveguideOperator</code></a> either through a LazySum or LazyTensor.</li><li><code>fout=nothing</code>: If given, this function <code>fout(t, psi)</code> is called every time step. Example: <code>fout(t,psi) = expect(A,psi)</code> will return the epectation value of A at everytimestep.  If <code>fout =1</code> the state psi is returned for all timesteps in a vector.  ATTENTION: The state <code>psi</code> is neither normalized nor permanent! It is still in use by the ode solver and therefore must not be changed.</li></ul><p><strong>Returns</strong></p><ul><li>if <code>fout=nothing</code> the output of the solver will be the state <code>ψ</code> at the last timestep. </li><li>if <code>fout</code> is given a tuple with the state <code>ψ</code> at the last timestep and the output of <code>fout</code> is given. If <code>fout</code> returns a tuple the tuple will be flattened.</li><li>if <code>fout = 1</code> <code>ψ</code> at all timesteps is returned.</li></ul><p><strong>Examples</strong></p><ul><li><code>fout(t,psi) = (expect(A,psi),expect(B,psi))</code> will result in  a tuple (ψ, ⟨A(t)⟩,⟨B(t)⟩), where <code>⟨A(t)⟩</code> is a vector with the expectation value of <code>A</code> as a function of time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/solver.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.waveguide_montecarlo-NTuple{4, Any}" href="#WaveguideQED.waveguide_montecarlo-NTuple{4, Any}"><code>WaveguideQED.waveguide_montecarlo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">waveguide_montecarlo(times,psi,H,J;fout=nothing)</code></pre><p>See documentation for <a href="#WaveguideQED.waveguide_evolution-Tuple{Any, Any, Any}"><code>waveguide_evolution</code></a> on how to define <code>fout</code>. J should be a list of collapse operators following documentation of <a href="https://docs.qojulia.org/api/#QuantumOptics.timeevolution.mcwf_dynamic"><code>timeevolution.mcwf_dynamic</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/solver.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveguideQED.zerophoton-Tuple{WaveguideBasis}" href="#WaveguideQED.zerophoton-Tuple{WaveguideBasis}"><code>WaveguideQED.zerophoton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zerophoton(bw::WaveguideBasis)</code></pre><p>Create a waveguide vacuum state <span>$| \emptyset  angle$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/basis.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!" href="#LinearAlgebra.mul!"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mul!(result::Ket{B1}, a::LazyTensor{B1,B2,F,I,T}, b::Ket{B2}, alpha, beta)</code></pre><p>In-place multiplication of operators/state vectors. Updates <code>result</code> as <code>result = alpha*a*b + beta*result</code>. <code>a</code> is a LazyTensor that contains a <a href="#WaveguideQED.WaveguideOperator"><code>WaveguideOperator</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L170-L174">source</a></section><section><div><pre><code class="nohighlight hljs">mul!(result::Ket{B1}, a::CavityWaveguideEmission, b::Ket{B2}, alpha, beta) where {B1&lt;:Basis,B2&lt;:Basis}
mul!(result::Ket{B1}, a::CavityWaveguideAbsorption, b::Ket{B2}, alpha, beta) where {B1&lt;:Basis,B2&lt;:Basis}</code></pre><p>Fast in-place multiplication of operators/state vectors. Updates <code>result</code> as <code>result = alpha*a*b + beta*result</code>. <code>a</code> is a <a href="#WaveguideQED.CavityWaveguideOperator"><code>CavityWaveguideOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/CavityWaveguideOperator.jl#L425-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.create" href="#QuantumOpticsBase.create"><code>QuantumOpticsBase.create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create(basis::WaveguideBasis{Np,1}) where {Np}
create(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}</code></pre><p>Creation operator <span>$w^\dagger$</span> for <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> <span>$w_i(t_k)^\dagger | \emptyset \rangle = | 1_k \emptyset \rangle_i$</span> with cutoff (maximum number of photons Np) where <code>i</code> is the index of the waveguide. <span>$t_k$</span> is determined by the timeindex property of the operator which can be changed by <a href="#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:WaveguideOperator"><code>set_waveguidetimeindex!(a::WaveguideOperator,k::Int)</code></a> </p><p><strong>Arguments</strong></p><ul><li>basis of type WaveguideBasis, defines cutoff photon number <code>Np</code> and number of waveguides <code>Nw</code></li><li><code>i</code> determines which waveguide the operator acts on and should be <code>i ≤ Nw</code>. If <code>Nw=1</code> then <code>i=1</code> is assumed (there is only one waveguide).</li></ul><p><strong>Returns</strong></p><p><a href="#WaveguideQED.WaveguideCreate"><code>WaveguideCreate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L87-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.destroy" href="#QuantumOpticsBase.destroy"><code>QuantumOpticsBase.destroy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">destroy(basis::WaveguideBasis{Np,1}) where {Np}
destroy(basis::WaveguideBasis{Np,Nw},i::Int) where {Np,Nw}</code></pre><p>Annihilation operator <span>$w$</span> for <a href="#WaveguideQED.WaveguideBasis"><code>WaveguideBasis</code></a> <span>$w_i(t_k) | 1_j \emptyset \rangle_i = \delta_{k,j} | \emptyset \rangle$</span> with cutoff (maximum number of photons Np) where <code>i</code> is the index of the waveguide. <span>$t_k$</span> is determined by the timeindex property of the operator which can be changed by <a href="#WaveguideQED.set_waveguidetimeindex!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:WaveguideOperator"><code>set_waveguidetimeindex!(a::WaveguideOperator,k::Int)</code></a> </p><p><strong>Arguments</strong></p><ul><li>basis of type WaveguideBasis, defines cutoff photon number <code>Np</code> and number of waveguides <code>Nw</code></li><li><code>i</code> determines which waveguide the operator acts on and should be <code>i ≤ Nw</code>. If <code>Nw=1</code> then <code>i=1</code> is assumed (there is only one waveguide).</li></ul><p><strong>Returns</strong></p><p><a href="#WaveguideQED.WaveguideDestroy"><code>WaveguideDestroy</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L63-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.dagger" href="#QuantumInterface.dagger"><code>QuantumInterface.dagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dagger(op::WaveguideCreate)
dagger(op::WaveguideCreate)</code></pre><p>Dagger opration on Waveguide operator. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L113-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.tensor" href="#QuantumInterface.tensor"><code>QuantumInterface.tensor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tensor(a::AbstractOperator,b::CavityWaveguideAbsorption)
tensor(a::CavityWaveguideAbsorption,b::AbstractOperator)
tensor(a::AbstractOperator,b::CavityWaveguideEmission)
tensor(a::CavityWaveguideEmission,b::AbstractOperator)</code></pre><p>Methods for tensorproducts between QuantumOptics.jl operators and <a href="#WaveguideQED.CavityWaveguideOperator"><code>CavityWaveguideOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/CavityWaveguideOperator.jl#L247-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.identityoperator" href="#QuantumInterface.identityoperator"><code>QuantumInterface.identityoperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">identityoperator(a::WaveguideOperator)</code></pre><p>Return identityoperator(a.basis_l).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/WaveguideOperator.jl#L153-L157">source</a></section><section><div><pre><code class="language-julia hljs">identityoperator(a::CavityWaveguideOperator)</code></pre><p>Return identityoperator(a.basis_l).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/WaveguideQED.jl/blob/528bee1934d8778a82f4a7793ecbe9f222d41030/src/CavityWaveguideOperator.jl#L234-L238">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../time_delay/">« Non-Markovian dynamics</a><a class="docs-footer-nextpage" href="../references/">References and suggested readings »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 1 July 2023 07:39">Saturday 1 July 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
